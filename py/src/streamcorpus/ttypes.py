#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,slots
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ContentCleanseLevel(object):
  """
  ContentCleanseLevel enumerates the various forms of the original
  content that might be used in `Tokens`.  This pertains to migrating
  from v3 to v4, because in v4 clean_html and clean_visible are
  deprecated.  Tokens can be generated from an NER tagger operating
  on `raw_characters`
  """
  raw = 0
  raw_characters = 1
  clean_html = 2
  clean_visible = 3

  _VALUES_TO_NAMES = {
    0: "raw",
    1: "raw_characters",
    2: "clean_html",
    3: "clean_visible",
  }

  _NAMES_TO_VALUES = {
    "raw": 0,
    "raw_characters": 1,
    "clean_html": 2,
    "clean_visible": 3,
  }

class OffsetType(object):
  """
  Offset and OffsetType are used by Annotation to identify the
  portion of a ContentItem that a human labeled with a tag.

    * annotation applies to a range of line numbers

    * annotation applies to a range of bytes

    * annotation applies to a range defined by xpaths (with relative char offsets)

    * annotation applies to a range of unicode chars

  Generally, bytes and lines should be avoided in favor of using
  unicode characters.
  """
  LINES = 0
  BYTES = 1
  CHARS = 2
  XPATH_CHARS = 3

  _VALUES_TO_NAMES = {
    0: "LINES",
    1: "BYTES",
    2: "CHARS",
    3: "XPATH_CHARS",
  }

  _NAMES_TO_VALUES = {
    "LINES": 0,
    "BYTES": 1,
    "CHARS": 2,
    "XPATH_CHARS": 3,
  }

class FlagType(object):
  """
  General purpose flags. These flags can be used to mark documents as
  meeting an extensible set of criteria.
  """
  PROFILE = 0

  _VALUES_TO_NAMES = {
    0: "PROFILE",
  }

  _NAMES_TO_VALUES = {
    "PROFILE": 0,
  }

class EntityType(object):
  """
  EntityType is deprecated in favor of EntityClass, which is
  hierarchical and more logical than this old, flat structure.
  """
  PER = 0
  ORG = 1
  LOC = 2
  TIME = 5
  DATE = 6
  MONEY = 7
  PERCENT = 8
  MISC = 9
  GPE = 10
  FAC = 11
  VEH = 12
  WEA = 13
  phone = 14
  email = 15
  URL = 16
  CUSTOM_TYPE = 17
  LIST = 18
  RELIGION = 19
  NATIONALITY = 20
  TITLE = 21
  EVENT = 22

  _VALUES_TO_NAMES = {
    0: "PER",
    1: "ORG",
    2: "LOC",
    5: "TIME",
    6: "DATE",
    7: "MONEY",
    8: "PERCENT",
    9: "MISC",
    10: "GPE",
    11: "FAC",
    12: "VEH",
    13: "WEA",
    14: "phone",
    15: "email",
    16: "URL",
    17: "CUSTOM_TYPE",
    18: "LIST",
    19: "RELIGION",
    20: "NATIONALITY",
    21: "TITLE",
    22: "EVENT",
  }

  _NAMES_TO_VALUES = {
    "PER": 0,
    "ORG": 1,
    "LOC": 2,
    "TIME": 5,
    "DATE": 6,
    "MONEY": 7,
    "PERCENT": 8,
    "MISC": 9,
    "GPE": 10,
    "FAC": 11,
    "VEH": 12,
    "WEA": 13,
    "phone": 14,
    "email": 15,
    "URL": 16,
    "CUSTOM_TYPE": 17,
    "LIST": 18,
    "RELIGION": 19,
    "NATIONALITY": 20,
    "TITLE": 21,
    "EVENT": 22,
  }

class EntityClass(object):
  """
  A hierarchical enumeration of types of entities designed to support
  description of entity mentions in human language discourse.  All
  types of things start off as natural forms, and then we carve out
  five human-derived types as top-level types that appear frequently
  in human discourse: person, organization, location, event, and
  artifact.

  A particular mention of an entity always has a primary type in this
  hierarchy.  That type should be selected based on what *defines*
  the entity in the context of that mention.  Thus, this assignment
  of in-context mentions to type values in this hierarchy should be
  universal, i.e. different people should arrive at the same type
  assignment.

  However, an entity may receive mentions from varying contexts that
  come from different parts of the hierarchy. For example, a spine
  surgeon may receive mentions of `PER_medical_surgeon_spine` in one
  context and also `PER_sports_coach_soccer` in an article describing
  her weekend activities with youth.  The top level taxonomy is
  intended to be mutually exclusive, e.g. the surgeon should not
  receive mentions of `NATURALFORM_animal_homo_sapiens`, which has
  been explicitly excluded from NATURALFORM in order to create the
  top-level type `person`.

  NB: the delimiter "_" is likely to work in most programming
  languages.

  These six top-level types are intended to not expand, and
  enhancements are intended to appear at lower levels in the
  hierarchy.
  """
  naturalform = 1
  person = 2
  organization = 3
  location = 4
  event = 5
  artifact = 6

  _VALUES_TO_NAMES = {
    1: "naturalform",
    2: "person",
    3: "organization",
    4: "location",
    5: "event",
    6: "artifact",
  }

  _NAMES_TO_VALUES = {
    "naturalform": 1,
    "person": 2,
    "organization": 3,
    "location": 4,
    "event": 5,
    "artifact": 6,
  }

class location(object):
  facility = 1
  coordinates = 2

  _VALUES_TO_NAMES = {
    1: "facility",
    2: "coordinates",
  }

  _NAMES_TO_VALUES = {
    "facility": 1,
    "coordinates": 2,
  }

class artifact(object):
  product = 1
  vehicle = 2
  weapon = 3
  cyber = 4
  money = 5

  _VALUES_TO_NAMES = {
    1: "product",
    2: "vehicle",
    3: "weapon",
    4: "cyber",
    5: "money",
  }

  _NAMES_TO_VALUES = {
    "product": 1,
    "vehicle": 2,
    "weapon": 3,
    "cyber": 4,
    "money": 5,
  }

class event(object):
  date = 1
  time = 2

  _VALUES_TO_NAMES = {
    1: "date",
    2: "time",
  }

  _NAMES_TO_VALUES = {
    "date": 1,
    "time": 2,
  }

class artifact_product(object):
  partnumber = 1

  _VALUES_TO_NAMES = {
    1: "partnumber",
  }

  _NAMES_TO_VALUES = {
    "partnumber": 1,
  }

class artifact_cyber(object):
  phone = 1
  email = 2
  IPv4 = 3
  IPv6 = 4
  skype = 5
  ICQ = 6
  QQ = 7
  AIM = 8
  MD5 = 9
  URL = 10
  file_path = 11
  CVE_ID = 12
  hex_value = 13
  byte_sequence = 14
  magic_value = 15

  _VALUES_TO_NAMES = {
    1: "phone",
    2: "email",
    3: "IPv4",
    4: "IPv6",
    5: "skype",
    6: "ICQ",
    7: "QQ",
    8: "AIM",
    9: "MD5",
    10: "URL",
    11: "file_path",
    12: "CVE_ID",
    13: "hex_value",
    14: "byte_sequence",
    15: "magic_value",
  }

  _NAMES_TO_VALUES = {
    "phone": 1,
    "email": 2,
    "IPv4": 3,
    "IPv6": 4,
    "skype": 5,
    "ICQ": 6,
    "QQ": 7,
    "AIM": 8,
    "MD5": 9,
    "URL": 10,
    "file_path": 11,
    "CVE_ID": 12,
    "hex_value": 13,
    "byte_sequence": 14,
    "magic_value": 15,
  }

class MentionType(object):
  NAME = 0
  PRO = 1
  NOM = 2

  _VALUES_TO_NAMES = {
    0: "NAME",
    1: "PRO",
    2: "NOM",
  }

  _NAMES_TO_VALUES = {
    "NAME": 0,
    "PRO": 1,
    "NOM": 2,
  }

class Gender(object):
  FEMALE = 0
  MALE = 1

  _VALUES_TO_NAMES = {
    0: "FEMALE",
    1: "MALE",
  }

  _NAMES_TO_VALUES = {
    "FEMALE": 0,
    "MALE": 1,
  }

class AttributeType(object):
  """
  Attributes are based primarily on TAC KBP, see also saved in this directory
  http://surdeanu.info/kbp2013/TAC_2013_KBP_Slot_Descriptions_1.0.pdf

  Only slots that are not resolvable to unique entities are listed
  here as attributes.  Most slots are relations, so see RelationType.
  """
  PER_AGE = 0
  PER_GENDER = 1
  PER_ALTERNATE_NAMES = 3
  PER_CAUSE_OF_DEATH = 4
  PER_TITLE = 5
  PER_CHARGES = 6
  ORG_ALTERNATE_NAMES = 7
  ORG_NUMBER_OF_EMPLOYEES_MEMBERS = 8

  _VALUES_TO_NAMES = {
    0: "PER_AGE",
    1: "PER_GENDER",
    3: "PER_ALTERNATE_NAMES",
    4: "PER_CAUSE_OF_DEATH",
    5: "PER_TITLE",
    6: "PER_CHARGES",
    7: "ORG_ALTERNATE_NAMES",
    8: "ORG_NUMBER_OF_EMPLOYEES_MEMBERS",
  }

  _NAMES_TO_VALUES = {
    "PER_AGE": 0,
    "PER_GENDER": 1,
    "PER_ALTERNATE_NAMES": 3,
    "PER_CAUSE_OF_DEATH": 4,
    "PER_TITLE": 5,
    "PER_CHARGES": 6,
    "ORG_ALTERNATE_NAMES": 7,
    "ORG_NUMBER_OF_EMPLOYEES_MEMBERS": 8,
  }

class SpanType(object):
  """
  To digest raw HTML, we first decode it to unicode and then lightly
  parse it into whitespaces, markup which could become XPath offsets,
  and visible text that could be analyzed as natural language. Spans
  can be divided into smaller contiguous spans, including sentences,
  words, phrases, punctuation, etc.
  """
  WHITESPACE = 0
  MARKUP = 1
  CONTENT = 2

  _VALUES_TO_NAMES = {
    0: "WHITESPACE",
    1: "MARKUP",
    2: "CONTENT",
  }

  _NAMES_TO_VALUES = {
    "WHITESPACE": 0,
    "MARKUP": 1,
    "CONTENT": 2,
  }

class ZoneType(object):
  UNZONED = 0
  HEADER = 1
  TITLE = 2
  BODY = 3
  FOOTER = 4

  _VALUES_TO_NAMES = {
    0: "UNZONED",
    1: "HEADER",
    2: "TITLE",
    3: "BODY",
    4: "FOOTER",
  }

  _NAMES_TO_VALUES = {
    "UNZONED": 0,
    "HEADER": 1,
    "TITLE": 2,
    "BODY": 3,
    "FOOTER": 4,
  }

class RelationType(object):
  """
  RelationType is used in Relation to map relation "name" to type.

  Relations 0 through 50 borrow from ACE with these string replacements:
  s/-// and s/./_/
  http://projects.ldc.upenn.edu/ace/docs/English-Events-Guidelines_v5.4.3.pdf

  Relations 51-  borrows from KBP slot filling
  http://surdeanu.info/kbp2013/TAC_2013_KBP_Slot_Descriptions_1.0.pdf

  Most entity slots are relations, so the PER_ and ORG_ and FAC_
  relations listed below are primary for slot filling.

  Many of the KBP-based slots are redundant or overlapping with the
  ACE-based slots.  The KBP-based slots are generally simpler and
  were developed to support knowledge base population rather than
  single-document extraction (as ACE was).  Therefore, for KB-focused
  tasks, we recommend using the Relations 51-
  """
  PHYS_Located = 0
  PHYS_Near = 1
  PARTWHOLE_Geographical = 2
  PARTWHOLE_Subsidiary = 3
  PARTWHOLE_Artifact = 4
  PERSOC_Business = 5
  PERSOC_Family = 6
  PERSOC_LastingPersonal = 7
  ORGAFF_Employment = 8
  ORGAFF_Ownership = 9
  ORGAFF_Founder = 10
  ORGAFF_StudentAlum = 11
  ORGAFF_SportsAffiliation = 12
  ORGAFF_InvestorShareholder = 13
  ORGAFF_Membership = 14
  ART_UserOwnerInventorManufacturer = 15
  GENAFF_CitizenResidentReligionEthnicity = 16
  GENAFF_OrgLocation = 17
  Business_DeclareBankruptcy = 18
  Business_EndOrg = 19
  Business_MergeOrg = 20
  Business_StartOrg = 21
  Conflict_Attack = 22
  Conflict_Demonstrate = 23
  Contact_PhoneWrite = 24
  Contact_Meet = 25
  Justice_Acquit = 26
  Justice_Appeal = 27
  Justice_ArrestJail = 28
  Justice_ChargeIndict = 29
  Justice_Convict = 30
  Justice_Execute = 31
  Justice_Extradite = 32
  Justice_Fine = 33
  Justice_Pardon = 34
  Justice_ReleaseParole = 35
  Justice_Sentence = 36
  Justice_Sue = 37
  Justice_TrialHearing = 38
  Life_BeBorn = 39
  Life_Die = 40
  Life_Divorce = 41
  Life_Injure = 42
  Life_Marry = 43
  Movement_Transport = 44
  Personnel_Elect = 45
  Personnel_EndPosition = 46
  Personnel_Nominate = 47
  Personnel_StartPosition = 48
  Transaction_TransferMoney = 49
  Transaction_TransferOwnership = 50
  PER_DATE_OF_BIRTH = 51
  PER_COUNTRY_OF_BIRTH = 52
  PER_STATEORPROVINCE_OF_BIRTH = 53
  PER_CITY_OF_BIRTH = 54
  PER_ORIGIN = 55
  PER_DATE_OF_DEATH = 56
  PER_COUNTRY_OF_DEATH = 57
  PER_STATEORPROVINCE_OF_DEATH = 58
  PER_CITY_OF_DEATH = 59
  PER_COUNTRIES_OF_RESIDENCE = 60
  PER_STATESORPROVINCES_OF_RESIDENCE = 61
  PER_CITIES_OF_RESIDENCE = 62
  PER_SCHOOLS_ATTENDED = 63
  PER_EMPLOYEE_OR_MEMBER_OF = 64
  PER_RELIGION = 65
  PER_SPOUSE = 66
  PER_CHILDREN = 67
  PER_PARENTS = 68
  PER_SIBLINGS = 69
  PER_OTHER_FAMILY = 70
  ORG_TOP_MEMBERS_EMPLOYEES = 71
  ORG_MEMBERS = 72
  ORG_MEMBER_OF = 73
  ORG_SUBSIDIARIES = 74
  ORG_PARENTS = 75
  ORG_FOUNDED_BY = 76
  ORG_DATE_FOUNDED = 77
  ORG_DATE_DISSOLVED = 78
  ORG_COUNTRY_OF_HEADQUARTERS = 79
  ORG_STATEORPROVINCE_OF_HEADQUARTERS = 80
  ORG_CITY_OF_HEADQUARTERS = 81
  ORG_SHAREHOLDERS = 82
  ORG_POLITICAL_OR_RELIGIOUS_AFFILIATION = 83
  ORG_WEBSITE = 84
  FAC_LOCATED = 85
  FAC_VISITED_BY = 86
  FAC_OWNER = 87
  PER_WON_AWARD = 88
  PER_MET_WITH = 89
  PER_ATTENDED = 90
  PER_VISITED = 91
  ORG_ATTENDED = 92
  ORG_VISITED = 93
  PER_WEBSITE = 94
  PER_NATIONALITY = 95

  _VALUES_TO_NAMES = {
    0: "PHYS_Located",
    1: "PHYS_Near",
    2: "PARTWHOLE_Geographical",
    3: "PARTWHOLE_Subsidiary",
    4: "PARTWHOLE_Artifact",
    5: "PERSOC_Business",
    6: "PERSOC_Family",
    7: "PERSOC_LastingPersonal",
    8: "ORGAFF_Employment",
    9: "ORGAFF_Ownership",
    10: "ORGAFF_Founder",
    11: "ORGAFF_StudentAlum",
    12: "ORGAFF_SportsAffiliation",
    13: "ORGAFF_InvestorShareholder",
    14: "ORGAFF_Membership",
    15: "ART_UserOwnerInventorManufacturer",
    16: "GENAFF_CitizenResidentReligionEthnicity",
    17: "GENAFF_OrgLocation",
    18: "Business_DeclareBankruptcy",
    19: "Business_EndOrg",
    20: "Business_MergeOrg",
    21: "Business_StartOrg",
    22: "Conflict_Attack",
    23: "Conflict_Demonstrate",
    24: "Contact_PhoneWrite",
    25: "Contact_Meet",
    26: "Justice_Acquit",
    27: "Justice_Appeal",
    28: "Justice_ArrestJail",
    29: "Justice_ChargeIndict",
    30: "Justice_Convict",
    31: "Justice_Execute",
    32: "Justice_Extradite",
    33: "Justice_Fine",
    34: "Justice_Pardon",
    35: "Justice_ReleaseParole",
    36: "Justice_Sentence",
    37: "Justice_Sue",
    38: "Justice_TrialHearing",
    39: "Life_BeBorn",
    40: "Life_Die",
    41: "Life_Divorce",
    42: "Life_Injure",
    43: "Life_Marry",
    44: "Movement_Transport",
    45: "Personnel_Elect",
    46: "Personnel_EndPosition",
    47: "Personnel_Nominate",
    48: "Personnel_StartPosition",
    49: "Transaction_TransferMoney",
    50: "Transaction_TransferOwnership",
    51: "PER_DATE_OF_BIRTH",
    52: "PER_COUNTRY_OF_BIRTH",
    53: "PER_STATEORPROVINCE_OF_BIRTH",
    54: "PER_CITY_OF_BIRTH",
    55: "PER_ORIGIN",
    56: "PER_DATE_OF_DEATH",
    57: "PER_COUNTRY_OF_DEATH",
    58: "PER_STATEORPROVINCE_OF_DEATH",
    59: "PER_CITY_OF_DEATH",
    60: "PER_COUNTRIES_OF_RESIDENCE",
    61: "PER_STATESORPROVINCES_OF_RESIDENCE",
    62: "PER_CITIES_OF_RESIDENCE",
    63: "PER_SCHOOLS_ATTENDED",
    64: "PER_EMPLOYEE_OR_MEMBER_OF",
    65: "PER_RELIGION",
    66: "PER_SPOUSE",
    67: "PER_CHILDREN",
    68: "PER_PARENTS",
    69: "PER_SIBLINGS",
    70: "PER_OTHER_FAMILY",
    71: "ORG_TOP_MEMBERS_EMPLOYEES",
    72: "ORG_MEMBERS",
    73: "ORG_MEMBER_OF",
    74: "ORG_SUBSIDIARIES",
    75: "ORG_PARENTS",
    76: "ORG_FOUNDED_BY",
    77: "ORG_DATE_FOUNDED",
    78: "ORG_DATE_DISSOLVED",
    79: "ORG_COUNTRY_OF_HEADQUARTERS",
    80: "ORG_STATEORPROVINCE_OF_HEADQUARTERS",
    81: "ORG_CITY_OF_HEADQUARTERS",
    82: "ORG_SHAREHOLDERS",
    83: "ORG_POLITICAL_OR_RELIGIOUS_AFFILIATION",
    84: "ORG_WEBSITE",
    85: "FAC_LOCATED",
    86: "FAC_VISITED_BY",
    87: "FAC_OWNER",
    88: "PER_WON_AWARD",
    89: "PER_MET_WITH",
    90: "PER_ATTENDED",
    91: "PER_VISITED",
    92: "ORG_ATTENDED",
    93: "ORG_VISITED",
    94: "PER_WEBSITE",
    95: "PER_NATIONALITY",
  }

  _NAMES_TO_VALUES = {
    "PHYS_Located": 0,
    "PHYS_Near": 1,
    "PARTWHOLE_Geographical": 2,
    "PARTWHOLE_Subsidiary": 3,
    "PARTWHOLE_Artifact": 4,
    "PERSOC_Business": 5,
    "PERSOC_Family": 6,
    "PERSOC_LastingPersonal": 7,
    "ORGAFF_Employment": 8,
    "ORGAFF_Ownership": 9,
    "ORGAFF_Founder": 10,
    "ORGAFF_StudentAlum": 11,
    "ORGAFF_SportsAffiliation": 12,
    "ORGAFF_InvestorShareholder": 13,
    "ORGAFF_Membership": 14,
    "ART_UserOwnerInventorManufacturer": 15,
    "GENAFF_CitizenResidentReligionEthnicity": 16,
    "GENAFF_OrgLocation": 17,
    "Business_DeclareBankruptcy": 18,
    "Business_EndOrg": 19,
    "Business_MergeOrg": 20,
    "Business_StartOrg": 21,
    "Conflict_Attack": 22,
    "Conflict_Demonstrate": 23,
    "Contact_PhoneWrite": 24,
    "Contact_Meet": 25,
    "Justice_Acquit": 26,
    "Justice_Appeal": 27,
    "Justice_ArrestJail": 28,
    "Justice_ChargeIndict": 29,
    "Justice_Convict": 30,
    "Justice_Execute": 31,
    "Justice_Extradite": 32,
    "Justice_Fine": 33,
    "Justice_Pardon": 34,
    "Justice_ReleaseParole": 35,
    "Justice_Sentence": 36,
    "Justice_Sue": 37,
    "Justice_TrialHearing": 38,
    "Life_BeBorn": 39,
    "Life_Die": 40,
    "Life_Divorce": 41,
    "Life_Injure": 42,
    "Life_Marry": 43,
    "Movement_Transport": 44,
    "Personnel_Elect": 45,
    "Personnel_EndPosition": 46,
    "Personnel_Nominate": 47,
    "Personnel_StartPosition": 48,
    "Transaction_TransferMoney": 49,
    "Transaction_TransferOwnership": 50,
    "PER_DATE_OF_BIRTH": 51,
    "PER_COUNTRY_OF_BIRTH": 52,
    "PER_STATEORPROVINCE_OF_BIRTH": 53,
    "PER_CITY_OF_BIRTH": 54,
    "PER_ORIGIN": 55,
    "PER_DATE_OF_DEATH": 56,
    "PER_COUNTRY_OF_DEATH": 57,
    "PER_STATEORPROVINCE_OF_DEATH": 58,
    "PER_CITY_OF_DEATH": 59,
    "PER_COUNTRIES_OF_RESIDENCE": 60,
    "PER_STATESORPROVINCES_OF_RESIDENCE": 61,
    "PER_CITIES_OF_RESIDENCE": 62,
    "PER_SCHOOLS_ATTENDED": 63,
    "PER_EMPLOYEE_OR_MEMBER_OF": 64,
    "PER_RELIGION": 65,
    "PER_SPOUSE": 66,
    "PER_CHILDREN": 67,
    "PER_PARENTS": 68,
    "PER_SIBLINGS": 69,
    "PER_OTHER_FAMILY": 70,
    "ORG_TOP_MEMBERS_EMPLOYEES": 71,
    "ORG_MEMBERS": 72,
    "ORG_MEMBER_OF": 73,
    "ORG_SUBSIDIARIES": 74,
    "ORG_PARENTS": 75,
    "ORG_FOUNDED_BY": 76,
    "ORG_DATE_FOUNDED": 77,
    "ORG_DATE_DISSOLVED": 78,
    "ORG_COUNTRY_OF_HEADQUARTERS": 79,
    "ORG_STATEORPROVINCE_OF_HEADQUARTERS": 80,
    "ORG_CITY_OF_HEADQUARTERS": 81,
    "ORG_SHAREHOLDERS": 82,
    "ORG_POLITICAL_OR_RELIGIOUS_AFFILIATION": 83,
    "ORG_WEBSITE": 84,
    "FAC_LOCATED": 85,
    "FAC_VISITED_BY": 86,
    "FAC_OWNER": 87,
    "PER_WON_AWARD": 88,
    "PER_MET_WITH": 89,
    "PER_ATTENDED": 90,
    "PER_VISITED": 91,
    "ORG_ATTENDED": 92,
    "ORG_VISITED": 93,
    "PER_WEBSITE": 94,
    "PER_NATIONALITY": 95,
  }

class Versions(object):
  """
  Versions of this protocol are enumerated so that when we expand,
  everybody can see which version a particular data file used.

  v0_1_0 refers to the kba.thrift definition, which was before
  Versions was included in the spec.
  """
  v0_2_0 = 0
  v0_3_0 = 1
  v0_4_0 = 2

  _VALUES_TO_NAMES = {
    0: "v0_2_0",
    1: "v0_3_0",
    2: "v0_4_0",
  }

  _NAMES_TO_VALUES = {
    "v0_2_0": 0,
    "v0_3_0": 1,
    "v0_4_0": 2,
  }


class StreamTime(object):
  """
  StreamTime is a timestamp measured in seconds since the 1970 epoch.
  epoch_ticks is always in the UTC timezone.  This is used in several
  structs below to record various moments in history.

  Implementations of these interfaces in various languages may
  provide convenience methods for insuring that these two fields are
  consistent with each other.

  Attributes:
   - epoch_ticks
   - zulu_timestamp
  """

  __slots__ = [ 
    'epoch_ticks',
    'zulu_timestamp',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'epoch_ticks', None, None, ), # 1
    (2, TType.STRING, 'zulu_timestamp', None, None, ), # 2
  )

  def __init__(self, epoch_ticks=None, zulu_timestamp=None,):
    self.epoch_ticks = epoch_ticks
    self.zulu_timestamp = zulu_timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.epoch_ticks = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.zulu_timestamp = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamTime')
    if self.epoch_ticks is not None:
      oprot.writeFieldBegin('epoch_ticks', TType.DOUBLE, 1)
      oprot.writeDouble(self.epoch_ticks)
      oprot.writeFieldEnd()
    if self.zulu_timestamp is not None:
      oprot.writeFieldBegin('zulu_timestamp', TType.STRING, 2)
      oprot.writeString(self.zulu_timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Annotator(object):
  """
  An Annotator object describes a human (or possibly a set of humans)
  who generated the data stored in a Label or Rating object.

  Attributes:
   - annotator_id
   - annotation_time: Approximate time when annotations/judgments/labels was rendered
  by human.  If this is missing, it means that the time was not
  recorded, which often happens when the author made the
  annotation.
  """

  __slots__ = [ 
    'annotator_id',
    'annotation_time',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'annotator_id', None, None, ), # 1
    (2, TType.STRUCT, 'annotation_time', (StreamTime, StreamTime.thrift_spec), None, ), # 2
  )

  def __init__(self, annotator_id=None, annotation_time=None,):
    self.annotator_id = annotator_id
    self.annotation_time = annotation_time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.annotator_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.annotation_time = StreamTime()
          self.annotation_time.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Annotator')
    if self.annotator_id is not None:
      oprot.writeFieldBegin('annotator_id', TType.STRING, 1)
      oprot.writeString(self.annotator_id)
      oprot.writeFieldEnd()
    if self.annotation_time is not None:
      oprot.writeFieldBegin('annotation_time', TType.STRUCT, 2)
      self.annotation_time.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Offset(object):
  """
  Offset specifies a range within a field of data in this ContentItem

  Attributes:
   - type: see comments on OffsetType
   - first: actual offset, which could be measured in bytes, chars, or lines.
  The data element identified by 'first' is included, and that
  identified by first+length is also included.

  In set notation,
      [first:first+length-1]

  or equivalently
      [first:first+length)

  or in list slicing, like python's:
      [first:first+length]

  While thrift treats these as signed integers, negative values are
  meaningless in this context, i.e. we do not end wrap.

  N.B. When this is an xpath offset, `length` is always `0` and `first`
  is always the first xpath offset in correspondence with the `xpath`
  member.
   - length
   - xpath: If this is an xpath offset, then this is set to the xpath address of the
  start text node. The relative start character offset is in `first`.
   - content_form: name of the data element inside a ContentItem to which this label
  applies, e.g. 'raw' 'clean_html' or 'clean_visible'.  Defaults to
  clean_visible, which is the most common case.

  Previously, this had the default value of "clean_visible" which
  was wasteful.  This field is now deprecated in favor of
  content_cleanse_level.
   - value: bytes specified by this offset extracted from the original; just
  to assist in debugging
   - xpath_end: If this is an xpath range, then this is set to the xpath address of the
  end text node. The relative end character offset is in `xpath2_offset`.

  Note that `xpath` and `first` have the same relationship as
  `xpath_end` and `xpath_end_offset`.
   - xpath_end_offset: If this is an xpath offset, then this is set to the ending xpath's
  relative char offset. (`first` contains the start offset.)

  Note that this offset participates in the half-open interval:

      [(xpath, first), (xpath_end, xpath_end_offset)).
   - content_cleanse_level: This enables Offset to be less bloated.
  """

  __slots__ = [ 
    'type',
    'first',
    'length',
    'xpath',
    'content_form',
    'value',
    'xpath_end',
    'xpath_end_offset',
    'content_cleanse_level',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I64, 'first', None, None, ), # 2
    (3, TType.I32, 'length', None, None, ), # 3
    (4, TType.STRING, 'xpath', None, None, ), # 4
    (5, TType.STRING, 'content_form', None, None, ), # 5
    (6, TType.STRING, 'value', None, None, ), # 6
    (7, TType.STRING, 'xpath_end', None, None, ), # 7
    (8, TType.I64, 'xpath_end_offset', None, None, ), # 8
    (9, TType.I32, 'content_cleanse_level', None, None, ), # 9
  )

  def __init__(self, type=None, first=None, length=None, xpath=None, content_form=None, value=None, xpath_end=None, xpath_end_offset=None, content_cleanse_level=None,):
    self.type = type
    self.first = first
    self.length = length
    self.xpath = xpath
    self.content_form = content_form
    self.value = value
    self.xpath_end = xpath_end
    self.xpath_end_offset = xpath_end_offset
    self.content_cleanse_level = content_cleanse_level

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.first = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.length = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.xpath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.content_form = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.xpath_end = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.xpath_end_offset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.content_cleanse_level = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Offset')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.first is not None:
      oprot.writeFieldBegin('first', TType.I64, 2)
      oprot.writeI64(self.first)
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I32, 3)
      oprot.writeI32(self.length)
      oprot.writeFieldEnd()
    if self.xpath is not None:
      oprot.writeFieldBegin('xpath', TType.STRING, 4)
      oprot.writeString(self.xpath)
      oprot.writeFieldEnd()
    if self.content_form is not None:
      oprot.writeFieldBegin('content_form', TType.STRING, 5)
      oprot.writeString(self.content_form)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 6)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.xpath_end is not None:
      oprot.writeFieldBegin('xpath_end', TType.STRING, 7)
      oprot.writeString(self.xpath_end)
      oprot.writeFieldEnd()
    if self.xpath_end_offset is not None:
      oprot.writeFieldBegin('xpath_end_offset', TType.I64, 8)
      oprot.writeI64(self.xpath_end_offset)
      oprot.writeFieldEnd()
    if self.content_cleanse_level is not None:
      oprot.writeFieldBegin('content_cleanse_level', TType.I32, 9)
      oprot.writeI32(self.content_cleanse_level)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Target(object):
  """
  Targets are "information targets," such as entities or topics,
  usually from a knowledge base, such as Wikipedia.

  Attributes:
   - target_id: unique string identifier, usually a URL into Wikipedia, Freebase,
  or some other structured reference system for info targets.
   - kb_id: kb_id is usually redundant if the target_id is a full URL,
  e.g. en.wikipedia.org
   - kb_snapshot_time: moment in history that the target_kb was accessed
  """

  __slots__ = [ 
    'target_id',
    'kb_id',
    'kb_snapshot_time',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'target_id', None, None, ), # 1
    (2, TType.STRING, 'kb_id', None, None, ), # 2
    (3, TType.STRUCT, 'kb_snapshot_time', (StreamTime, StreamTime.thrift_spec), None, ), # 3
  )

  def __init__(self, target_id=None, kb_id=None, kb_snapshot_time=None,):
    self.target_id = target_id
    self.kb_id = kb_id
    self.kb_snapshot_time = kb_snapshot_time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.target_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.kb_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.kb_snapshot_time = StreamTime()
          self.kb_snapshot_time.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Target')
    if self.target_id is not None:
      oprot.writeFieldBegin('target_id', TType.STRING, 1)
      oprot.writeString(self.target_id)
      oprot.writeFieldEnd()
    if self.kb_id is not None:
      oprot.writeFieldBegin('kb_id', TType.STRING, 2)
      oprot.writeString(self.kb_id)
      oprot.writeFieldEnd()
    if self.kb_snapshot_time is not None:
      oprot.writeFieldBegin('kb_snapshot_time', TType.STRUCT, 3)
      self.kb_snapshot_time.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Label(object):
  """
  Labels are human generated assertions about a portion of a document
  For example, a human author might label their own text by inserting
  hyperlinks to Wikipedia, or a NIST assessor might record which
  tokens in a text mention a target entity.

  Label instances can be attached in three palces:
   -  Token.labels  list
   -  Sentence.labels  list
   -  ContentItem.labels  map

  Attributes:
   - annotator: identifies the source of this Label
   - target: identifies the information need assessed by annotator
   - offsets: pointers to data to which this label applies.  If empty, then
  label applies to the entire Token, Sentence, or ContentItem to
  which it is attached.
   - positive: Labels are usually positive assertions that the token mentions
  the target_id.  It is sometimes useful to collect negative
  assertions that a token is NOT the target_id, which can be
  indicated by setting Label.positive to False
   - comments: Save notes from Annotator about this Rating
   - mentions: Record strings that are "mentions" of the target in this text.

  Note: there used to be a field 'contains mention' which would
  allow for a document to be labeled as about a thing without
  containing a string naming the thing. That hardly ever actually
  happened, but maybe someday it could be added back if needed.
   - relevance: numerical score assigned by annotator to "judge" or "rate" the
  utility of this StreamItem to addressing the target information
  need.  The range and interpretation of relevance numbers depends
  on the annotator.  relevance can represent a rank ordering or an
  enumeration such as -1=Garbage, 0=Neutral, 1=Useful, 2=Vital
   - stream_id: Stream ID for this label.  This is the stream_id for the source
  StreamItem, if a label is stored independently from its original
  data.
   - flags: General purpose flags. These flags can be used to mark documents
  as meeting an extensible set of criteria.
   - confidence: Confidence that this label is correct.  Created by automatic
  algorithms that create Label objects in Entity.kb_links
  """

  __slots__ = [ 
    'annotator',
    'target',
    'offsets',
    'positive',
    'comments',
    'mentions',
    'relevance',
    'stream_id',
    'flags',
    'confidence',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'annotator', (Annotator, Annotator.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'target', (Target, Target.thrift_spec), None, ), # 2
    (3, TType.MAP, 'offsets', (TType.I32,None,TType.STRUCT,(Offset, Offset.thrift_spec)), {
    }, ), # 3
    (4, TType.BOOL, 'positive', None, True, ), # 4
    (5, TType.STRING, 'comments', None, None, ), # 5
    (6, TType.LIST, 'mentions', (TType.STRING,None), None, ), # 6
    (7, TType.I16, 'relevance', None, None, ), # 7
    (8, TType.STRING, 'stream_id', None, None, ), # 8
    (9, TType.LIST, 'flags', (TType.I32,None), None, ), # 9
    (10, TType.DOUBLE, 'confidence', None, None, ), # 10
  )

  def __init__(self, annotator=None, target=None, offsets=thrift_spec[3][4], positive=thrift_spec[4][4], comments=None, mentions=None, relevance=None, stream_id=None, flags=None, confidence=None,):
    self.annotator = annotator
    self.target = target
    if offsets is self.thrift_spec[3][4]:
      offsets = {
    }
    self.offsets = offsets
    self.positive = positive
    self.comments = comments
    self.mentions = mentions
    self.relevance = relevance
    self.stream_id = stream_id
    self.flags = flags
    self.confidence = confidence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.annotator = Annotator()
          self.annotator.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.target = Target()
          self.target.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.offsets = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          for _i4 in xrange(_size0):
            _key5 = iprot.readI32();
            _val6 = Offset()
            _val6.read(iprot)
            self.offsets[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.positive = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.comments = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.mentions = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.mentions.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.relevance = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.stream_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.flags = []
          (_etype16, _size13) = iprot.readListBegin()
          for _i17 in xrange(_size13):
            _elem18 = iprot.readI32();
            self.flags.append(_elem18)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Label')
    if self.annotator is not None:
      oprot.writeFieldBegin('annotator', TType.STRUCT, 1)
      self.annotator.write(oprot)
      oprot.writeFieldEnd()
    if self.target is not None:
      oprot.writeFieldBegin('target', TType.STRUCT, 2)
      self.target.write(oprot)
      oprot.writeFieldEnd()
    if self.offsets is not None:
      oprot.writeFieldBegin('offsets', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.offsets))
      for kiter19,viter20 in self.offsets.items():
        oprot.writeI32(kiter19)
        viter20.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.positive is not None:
      oprot.writeFieldBegin('positive', TType.BOOL, 4)
      oprot.writeBool(self.positive)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 5)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    if self.mentions is not None:
      oprot.writeFieldBegin('mentions', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.mentions))
      for iter21 in self.mentions:
        oprot.writeString(iter21)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.relevance is not None:
      oprot.writeFieldBegin('relevance', TType.I16, 7)
      oprot.writeI16(self.relevance)
      oprot.writeFieldEnd()
    if self.stream_id is not None:
      oprot.writeFieldBegin('stream_id', TType.STRING, 8)
      oprot.writeString(self.stream_id)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.LIST, 9)
      oprot.writeListBegin(TType.I32, len(self.flags))
      for iter22 in self.flags:
        oprot.writeI32(iter22)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 10)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class EntityClassAddress(object):
  """
  The class of entity referenced by an in-context mention is a list of
  values in the EntityClass hierarchy, which is represented by a list
  of integers:

  Attributes:
   - address
   - confidence
  """

  __slots__ = [ 
    'address',
    'confidence',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'address', (TType.I16,None), None, ), # 1
    (2, TType.DOUBLE, 'confidence', None, None, ), # 2
  )

  def __init__(self, address=None, confidence=None,):
    self.address = address
    self.confidence = confidence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.address = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = iprot.readI16();
            self.address.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EntityClassAddress')
    if self.address is not None:
      oprot.writeFieldBegin('address', TType.LIST, 1)
      oprot.writeListBegin(TType.I16, len(self.address))
      for iter29 in self.address:
        oprot.writeI16(iter29)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 2)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Attribute(object):
  """
  Description of an attribute of an entity discovered by a tagger in
  the text.

  Attributes:
   - attribute_type: The type of the attribute, see documentation for AttributeType
   - evidence: UTF-8 string that tagger asserts as evidence of an attribute
   - value: A normalized, strongly typed value derived from the evidence.
  The actual type must be determined by programmatically
  interpretint the attribute_type.  For example,
  attribute_type==AttributeType.PER_GENDER implies that this value
  will be a string containing an integer index into the Gender
  enum.

  For attribute_type that imply a value of type date-time, the
  value is a zulu_timestamp string from a StreamTime instance.
   - sentence_id: Zero-based index into the sentences array for this TaggerID
   - mention_id: Index into the mentions in the document.  This identifies the
  mention to which the attrribute applies
  """

  __slots__ = [ 
    'attribute_type',
    'evidence',
    'value',
    'sentence_id',
    'mention_id',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'attribute_type', None, None, ), # 1
    (2, TType.STRING, 'evidence', None, None, ), # 2
    (3, TType.STRING, 'value', None, None, ), # 3
    (4, TType.I32, 'sentence_id', None, None, ), # 4
    (5, TType.I32, 'mention_id', None, None, ), # 5
  )

  def __init__(self, attribute_type=None, evidence=None, value=None, sentence_id=None, mention_id=None,):
    self.attribute_type = attribute_type
    self.evidence = evidence
    self.value = value
    self.sentence_id = sentence_id
    self.mention_id = mention_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.attribute_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.evidence = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.sentence_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.mention_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Attribute')
    if self.attribute_type is not None:
      oprot.writeFieldBegin('attribute_type', TType.I32, 1)
      oprot.writeI32(self.attribute_type)
      oprot.writeFieldEnd()
    if self.evidence is not None:
      oprot.writeFieldBegin('evidence', TType.STRING, 2)
      oprot.writeString(self.evidence)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.sentence_id is not None:
      oprot.writeFieldBegin('sentence_id', TType.I32, 4)
      oprot.writeI32(self.sentence_id)
      oprot.writeFieldEnd()
    if self.mention_id is not None:
      oprot.writeFieldBegin('mention_id', TType.I32, 5)
      oprot.writeI32(self.mention_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Token(object):
  """
  Textual tokens identified by an NLP pipeline and marked up with
  metadata from automatic taggers and possibly also Labels from
  humans.

  Attributes:
   - token_num: zero-based index into the stream of tokens from a document
   - token: actual token string, must always be a UTF8 encoded string, not a
  unicode string, because thrift stores them as 8-bit.
   - offsets: offsets into the original data (see Offset.content_form)
   - sentence_pos: zero-based index into the sentence, which is used for dependency
  parsed data
   - lemma: lemmatization of the token, again must be UTF8
   - pos: part of speech labels defined by Penn TreeBank:
  http://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html
  Should probably convert this to an enum, analogous to EntityType
   - entity_type: entity type from named entity recognizer (classifier)
   - mention_id: Identifier for a each mention in this TaggerID's description of
  the document.  Is unique at the document level.  Serves two
  purposes:

    1) Distinguishing multi-token mention.  Needed when the
    entity_type and equiv_id do not change between tokens that are
    part of separate mentions, e.g. "The senator is known to his
    friends as David, Davy, Zeus, and Mr. Elephant."

    2) Refering to mentions used in Relation objects.
   - equiv_id: Within-doc coref chain ID.  That is, identifier of equivalence
  class of co-referent tokens.  Default is -1, meaning None.
   - parent_id: parent sentence_pos in dependency parse. Default is -1, ie None
   - dependency_path: grammatical relation label on path to parent in dependency parse,
  defined by whatever tagger was used -- should pick a canonical
  definition here and convert it to an enum.
   - labels: Labels attached to this token, defaults to an empty map
   - mention_type: Identify the type of mention, e.g. pronoun, description, proper name
   - custom_entity_type: CUSTOM entity type from named entity recognizer (classifier).  If
  used, then entity_type should be set to EntityType.CUSTOM_TYPE,
  i.e. 17.

  This is useful when a specialized tagger has a large number of
  unique entity types, such as entity:artefact:weapon:blunt Rather
  than expand EntityType with many more subtypes, we can escape the
  protection of the enum and just use a string here:
  """

  __slots__ = [ 
    'token_num',
    'token',
    'offsets',
    'sentence_pos',
    'lemma',
    'pos',
    'entity_type',
    'mention_id',
    'equiv_id',
    'parent_id',
    'dependency_path',
    'labels',
    'mention_type',
    'custom_entity_type',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'token_num', None, None, ), # 1
    (2, TType.STRING, 'token', None, None, ), # 2
    (3, TType.MAP, 'offsets', (TType.I32,None,TType.STRUCT,(Offset, Offset.thrift_spec)), {
    }, ), # 3
    (4, TType.I32, 'sentence_pos', None, -1, ), # 4
    (5, TType.STRING, 'lemma', None, None, ), # 5
    (6, TType.STRING, 'pos', None, None, ), # 6
    (7, TType.I32, 'entity_type', None, None, ), # 7
    (8, TType.I32, 'mention_id', None, -1, ), # 8
    (9, TType.I32, 'equiv_id', None, -1, ), # 9
    (10, TType.I32, 'parent_id', None, -1, ), # 10
    (11, TType.STRING, 'dependency_path', None, None, ), # 11
    (12, TType.MAP, 'labels', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Label, Label.thrift_spec))), {
    }, ), # 12
    (13, TType.I32, 'mention_type', None, None, ), # 13
    (14, TType.STRING, 'custom_entity_type', None, None, ), # 14
  )

  def __init__(self, token_num=None, token=None, offsets=thrift_spec[3][4], sentence_pos=thrift_spec[4][4], lemma=None, pos=None, entity_type=None, mention_id=thrift_spec[8][4], equiv_id=thrift_spec[9][4], parent_id=thrift_spec[10][4], dependency_path=None, labels=thrift_spec[12][4], mention_type=None, custom_entity_type=None,):
    self.token_num = token_num
    self.token = token
    if offsets is self.thrift_spec[3][4]:
      offsets = {
    }
    self.offsets = offsets
    self.sentence_pos = sentence_pos
    self.lemma = lemma
    self.pos = pos
    self.entity_type = entity_type
    if mention_id is self.thrift_spec[8][4]:
      mention_id = -1
    self.mention_id = mention_id
    self.equiv_id = equiv_id
    self.parent_id = parent_id
    self.dependency_path = dependency_path
    if labels is self.thrift_spec[12][4]:
      labels = {
    }
    self.labels = labels
    self.mention_type = mention_type
    self.custom_entity_type = custom_entity_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.token_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.offsets = {}
          (_ktype31, _vtype32, _size30 ) = iprot.readMapBegin() 
          for _i34 in xrange(_size30):
            _key35 = iprot.readI32();
            _val36 = Offset()
            _val36.read(iprot)
            self.offsets[_key35] = _val36
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.sentence_pos = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.lemma = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.pos = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.entity_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.mention_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.equiv_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.parent_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.dependency_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.MAP:
          self.labels = {}
          (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin() 
          for _i41 in xrange(_size37):
            _key42 = iprot.readString();
            _val43 = []
            (_etype47, _size44) = iprot.readListBegin()
            for _i48 in xrange(_size44):
              _elem49 = Label()
              _elem49.read(iprot)
              _val43.append(_elem49)
            iprot.readListEnd()
            self.labels[_key42] = _val43
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.mention_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.custom_entity_type = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Token')
    if self.token_num is not None:
      oprot.writeFieldBegin('token_num', TType.I32, 1)
      oprot.writeI32(self.token_num)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 2)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.offsets is not None:
      oprot.writeFieldBegin('offsets', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.offsets))
      for kiter50,viter51 in self.offsets.items():
        oprot.writeI32(kiter50)
        viter51.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.sentence_pos is not None:
      oprot.writeFieldBegin('sentence_pos', TType.I32, 4)
      oprot.writeI32(self.sentence_pos)
      oprot.writeFieldEnd()
    if self.lemma is not None:
      oprot.writeFieldBegin('lemma', TType.STRING, 5)
      oprot.writeString(self.lemma)
      oprot.writeFieldEnd()
    if self.pos is not None:
      oprot.writeFieldBegin('pos', TType.STRING, 6)
      oprot.writeString(self.pos)
      oprot.writeFieldEnd()
    if self.entity_type is not None:
      oprot.writeFieldBegin('entity_type', TType.I32, 7)
      oprot.writeI32(self.entity_type)
      oprot.writeFieldEnd()
    if self.mention_id is not None:
      oprot.writeFieldBegin('mention_id', TType.I32, 8)
      oprot.writeI32(self.mention_id)
      oprot.writeFieldEnd()
    if self.equiv_id is not None:
      oprot.writeFieldBegin('equiv_id', TType.I32, 9)
      oprot.writeI32(self.equiv_id)
      oprot.writeFieldEnd()
    if self.parent_id is not None:
      oprot.writeFieldBegin('parent_id', TType.I32, 10)
      oprot.writeI32(self.parent_id)
      oprot.writeFieldEnd()
    if self.dependency_path is not None:
      oprot.writeFieldBegin('dependency_path', TType.STRING, 11)
      oprot.writeString(self.dependency_path)
      oprot.writeFieldEnd()
    if self.labels is not None:
      oprot.writeFieldBegin('labels', TType.MAP, 12)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.labels))
      for kiter52,viter53 in self.labels.items():
        oprot.writeString(kiter52)
        oprot.writeListBegin(TType.STRUCT, len(viter53))
        for iter54 in viter53:
          iter54.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.mention_type is not None:
      oprot.writeFieldBegin('mention_type', TType.I32, 13)
      oprot.writeI32(self.mention_type)
      oprot.writeFieldEnd()
    if self.custom_entity_type is not None:
      oprot.writeFieldBegin('custom_entity_type', TType.STRING, 14)
      oprot.writeString(self.custom_entity_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Sentence(object):
  """
  Attributes:
   - tokens: tokens in this sentence
   - labels: array of instances of Label attached to this sentence, defaults to
  an empty map
  """

  __slots__ = [ 
    'tokens',
    'labels',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tokens', (TType.STRUCT,(Token, Token.thrift_spec)), [
    ], ), # 1
    (2, TType.MAP, 'labels', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Label, Label.thrift_spec))), {
    }, ), # 2
  )

  def __init__(self, tokens=thrift_spec[1][4], labels=thrift_spec[2][4],):
    if tokens is self.thrift_spec[1][4]:
      tokens = [
    ]
    self.tokens = tokens
    if labels is self.thrift_spec[2][4]:
      labels = {
    }
    self.labels = labels

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tokens = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = Token()
            _elem60.read(iprot)
            self.tokens.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.labels = {}
          (_ktype62, _vtype63, _size61 ) = iprot.readMapBegin() 
          for _i65 in xrange(_size61):
            _key66 = iprot.readString();
            _val67 = []
            (_etype71, _size68) = iprot.readListBegin()
            for _i72 in xrange(_size68):
              _elem73 = Label()
              _elem73.read(iprot)
              _val67.append(_elem73)
            iprot.readListEnd()
            self.labels[_key66] = _val67
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Sentence')
    if self.tokens is not None:
      oprot.writeFieldBegin('tokens', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tokens))
      for iter74 in self.tokens:
        iter74.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.labels is not None:
      oprot.writeFieldBegin('labels', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.labels))
      for kiter75,viter76 in self.labels.items():
        oprot.writeString(kiter75)
        oprot.writeListBegin(TType.STRUCT, len(viter76))
        for iter77 in viter76:
          iter77.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Tagging(object):
  """
  Attributes:
   - tagger_id
   - raw_tagging: raw output of the tagging tool
   - tagger_config: short human-readable description of configuration parameters
   - tagger_version: short human-readable version string of the tagging tool
   - generation_time: time that tagging was generated
  """

  __slots__ = [ 
    'tagger_id',
    'raw_tagging',
    'tagger_config',
    'tagger_version',
    'generation_time',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tagger_id', None, None, ), # 1
    (2, TType.STRING, 'raw_tagging', None, None, ), # 2
    (3, TType.STRING, 'tagger_config', None, None, ), # 3
    (4, TType.STRING, 'tagger_version', None, None, ), # 4
    (5, TType.STRUCT, 'generation_time', (StreamTime, StreamTime.thrift_spec), None, ), # 5
  )

  def __init__(self, tagger_id=None, raw_tagging=None, tagger_config=None, tagger_version=None, generation_time=None,):
    self.tagger_id = tagger_id
    self.raw_tagging = raw_tagging
    self.tagger_config = tagger_config
    self.tagger_version = tagger_version
    self.generation_time = generation_time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tagger_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.raw_tagging = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tagger_config = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tagger_version = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.generation_time = StreamTime()
          self.generation_time.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Tagging')
    if self.tagger_id is not None:
      oprot.writeFieldBegin('tagger_id', TType.STRING, 1)
      oprot.writeString(self.tagger_id)
      oprot.writeFieldEnd()
    if self.raw_tagging is not None:
      oprot.writeFieldBegin('raw_tagging', TType.STRING, 2)
      oprot.writeString(self.raw_tagging)
      oprot.writeFieldEnd()
    if self.tagger_config is not None:
      oprot.writeFieldBegin('tagger_config', TType.STRING, 3)
      oprot.writeString(self.tagger_config)
      oprot.writeFieldEnd()
    if self.tagger_version is not None:
      oprot.writeFieldBegin('tagger_version', TType.STRING, 4)
      oprot.writeString(self.tagger_version)
      oprot.writeFieldEnd()
    if self.generation_time is not None:
      oprot.writeFieldBegin('generation_time', TType.STRUCT, 5)
      self.generation_time.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Selector(object):
  """
  Desription of a selector discovered by an extractor in the text.

  Attributes:
   - selector_type: what type of selector this is
   - raw_selector: the selector string as it appears in the document
   - canonical_selector: the selector string in a canonical form
   - offsets: pointer to the selector string within the clean_visible document
   - metadata: optional metadata binary string, such as a JSON or CBOR blob,
  depends on the selector_type.
  """

  __slots__ = [ 
    'selector_type',
    'raw_selector',
    'canonical_selector',
    'offsets',
    'metadata',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'selector_type', None, None, ), # 1
    (2, TType.STRING, 'raw_selector', None, None, ), # 2
    (3, TType.STRING, 'canonical_selector', None, None, ), # 3
    (4, TType.MAP, 'offsets', (TType.I32,None,TType.STRUCT,(Offset, Offset.thrift_spec)), {
    }, ), # 4
    (5, TType.STRING, 'metadata', None, None, ), # 5
  )

  def __init__(self, selector_type=None, raw_selector=None, canonical_selector=None, offsets=thrift_spec[4][4], metadata=None,):
    self.selector_type = selector_type
    self.raw_selector = raw_selector
    self.canonical_selector = canonical_selector
    if offsets is self.thrift_spec[4][4]:
      offsets = {
    }
    self.offsets = offsets
    self.metadata = metadata

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.selector_type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.raw_selector = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.canonical_selector = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.offsets = {}
          (_ktype79, _vtype80, _size78 ) = iprot.readMapBegin() 
          for _i82 in xrange(_size78):
            _key83 = iprot.readI32();
            _val84 = Offset()
            _val84.read(iprot)
            self.offsets[_key83] = _val84
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.metadata = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Selector')
    if self.selector_type is not None:
      oprot.writeFieldBegin('selector_type', TType.STRING, 1)
      oprot.writeString(self.selector_type)
      oprot.writeFieldEnd()
    if self.raw_selector is not None:
      oprot.writeFieldBegin('raw_selector', TType.STRING, 2)
      oprot.writeString(self.raw_selector)
      oprot.writeFieldEnd()
    if self.canonical_selector is not None:
      oprot.writeFieldBegin('canonical_selector', TType.STRING, 3)
      oprot.writeString(self.canonical_selector)
      oprot.writeFieldEnd()
    if self.offsets is not None:
      oprot.writeFieldBegin('offsets', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.offsets))
      for kiter85,viter86 in self.offsets.items():
        oprot.writeI32(kiter85)
        viter86.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRING, 5)
      oprot.writeString(self.metadata)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Zone(object):
  """
  Desription of a Zone discovered by an extractor in the text.

  Attributes:
   - zone_type: what type of zone this is
   - offsets: For a given OffsetType provide a *list* of Offset objects
  """

  __slots__ = [ 
    'zone_type',
    'offsets',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'zone_type', None, None, ), # 1
    (2, TType.MAP, 'offsets', (TType.I32,None,TType.LIST,(TType.STRUCT,(Offset, Offset.thrift_spec))), {
    }, ), # 2
  )

  def __init__(self, zone_type=None, offsets=thrift_spec[2][4],):
    self.zone_type = zone_type
    if offsets is self.thrift_spec[2][4]:
      offsets = {
    }
    self.offsets = offsets

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.zone_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.offsets = {}
          (_ktype88, _vtype89, _size87 ) = iprot.readMapBegin() 
          for _i91 in xrange(_size87):
            _key92 = iprot.readI32();
            _val93 = []
            (_etype97, _size94) = iprot.readListBegin()
            for _i98 in xrange(_size94):
              _elem99 = Offset()
              _elem99.read(iprot)
              _val93.append(_elem99)
            iprot.readListEnd()
            self.offsets[_key92] = _val93
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Zone')
    if self.zone_type is not None:
      oprot.writeFieldBegin('zone_type', TType.I32, 1)
      oprot.writeI32(self.zone_type)
      oprot.writeFieldEnd()
    if self.offsets is not None:
      oprot.writeFieldBegin('offsets', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.offsets))
      for kiter100,viter101 in self.offsets.items():
        oprot.writeI32(kiter100)
        oprot.writeListBegin(TType.STRUCT, len(viter101))
        for iter102 in viter101:
          iter102.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Relation(object):
  """
  Description of a relation between two entities that a tagger
  discovered in the text.

  Attributes:
   - relation_type: The type of the relation, see documentation for RelationType

   - sentence_id_1: Zero-based index into the sentences array for this TaggerID
   - mention_id_1: Index into the mentions in the document.  This identifies the
  origin of the relation.  For example, the relation
     (Bob, PHYS_Located, Chicago)
  would have mention_id_1 point to Bob.
   - sentence_id_2: Zero-based index into the sentences array for this TaggerID
   - mention_id_2: Index into the mentions in the document. This identifies the
  origin of the relation.  For example, the relation
     (Bob, PHYS_Located, Chicago)
  would have mention_id_2 point to Chicago.
  """

  __slots__ = [ 
    'relation_type',
    'sentence_id_1',
    'mention_id_1',
    'sentence_id_2',
    'mention_id_2',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'relation_type', None, None, ), # 1
    (2, TType.I32, 'sentence_id_1', None, None, ), # 2
    (3, TType.I32, 'mention_id_1', None, None, ), # 3
    (4, TType.I32, 'sentence_id_2', None, None, ), # 4
    (5, TType.I32, 'mention_id_2', None, None, ), # 5
  )

  def __init__(self, relation_type=None, sentence_id_1=None, mention_id_1=None, sentence_id_2=None, mention_id_2=None,):
    self.relation_type = relation_type
    self.sentence_id_1 = sentence_id_1
    self.mention_id_1 = mention_id_1
    self.sentence_id_2 = sentence_id_2
    self.mention_id_2 = mention_id_2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.relation_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.sentence_id_1 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mention_id_1 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.sentence_id_2 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.mention_id_2 = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Relation')
    if self.relation_type is not None:
      oprot.writeFieldBegin('relation_type', TType.I32, 1)
      oprot.writeI32(self.relation_type)
      oprot.writeFieldEnd()
    if self.sentence_id_1 is not None:
      oprot.writeFieldBegin('sentence_id_1', TType.I32, 2)
      oprot.writeI32(self.sentence_id_1)
      oprot.writeFieldEnd()
    if self.mention_id_1 is not None:
      oprot.writeFieldBegin('mention_id_1', TType.I32, 3)
      oprot.writeI32(self.mention_id_1)
      oprot.writeFieldEnd()
    if self.sentence_id_2 is not None:
      oprot.writeFieldBegin('sentence_id_2', TType.I32, 4)
      oprot.writeI32(self.sentence_id_2)
      oprot.writeFieldEnd()
    if self.mention_id_2 is not None:
      oprot.writeFieldBegin('mention_id_2', TType.I32, 5)
      oprot.writeI32(self.mention_id_2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Language(object):
  """
  Description of a natural language used in text

  Attributes:
   - code: two letter code for the language
   - name
  """

  __slots__ = [ 
    'code',
    'name',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'code', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, code=None, name=None,):
    self.code = code
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.code = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Language')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.STRING, 1)
      oprot.writeString(self.code)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Mention(object):
  """
  Description of a natural language used in text

  Attributes:
   - confidence: A bridge structure carrying references into other structures...  TODO: explain more
   - sentence_id
   - span_range
  """

  __slots__ = [ 
    'confidence',
    'sentence_id',
    'span_range',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'confidence', None, None, ), # 1
    (2, TType.I32, 'sentence_id', None, None, ), # 2
    (3, TType.LIST, 'span_range', (TType.I32,None), None, ), # 3
  )

  def __init__(self, confidence=None, sentence_id=None, span_range=None,):
    self.confidence = confidence
    self.sentence_id = sentence_id
    self.span_range = span_range

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.sentence_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.span_range = []
          (_etype106, _size103) = iprot.readListBegin()
          for _i107 in xrange(_size103):
            _elem108 = iprot.readI32();
            self.span_range.append(_elem108)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Mention')
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 1)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    if self.sentence_id is not None:
      oprot.writeFieldBegin('sentence_id', TType.I32, 2)
      oprot.writeI32(self.sentence_id)
      oprot.writeFieldEnd()
    if self.span_range is not None:
      oprot.writeFieldBegin('span_range', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.span_range))
      for iter109 in self.span_range:
        oprot.writeI32(iter109)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Entity(object):
  """
  A knowledge-base-like record for each entity recognized in
  `StreamItem.body`.  This serves two purposes: it carries the list
  of Mentions for efficiently highlighting mentions of the entity in
  a visual display of the document, and it points to the
  `body.contexts` that characterize the entity.

  Attributes:
   - coref_chain_id: Consider these possible methods of constructing identifiers for
  entities mentioned within a document:

  - arbitrary integer selected by NER engine(s), which is not
    stable across software upgrades that re-analyze the text.

  - first character in the "best" mention.  Fails to be unique on
    mentions like "Albany First National Bank", which might occur
    in an article about Albany.

  - tuple of (first, length) for the best mention.  Tuples do not
    work as keys in a map.

  - cbor.dumps((first, length))does work as a key in a map.
   - mentions: List of `Mention` objects in order of appearance in text.
   - best_id: Index position in mentions of a representative mention, which is
  also used to construct the coref_chain_id
   - entity_classes: See discussion of hierarchical entity classes.
   - descriptions: A general structure for holding attribute-like information that
  has not yet been reified to a particular ontology or schema.
   - associations: A general structure for holding entity-to-entity relation-like
  information that has not yet been reified to a particular
  ontology or schema.
   - kb_links: When an Entity is resolved, its meaning should be recorded in a
  `Label` object.
  """

  __slots__ = [ 
    'coref_chain_id',
    'mentions',
    'best_id',
    'entity_classes',
    'descriptions',
    'associations',
    'kb_links',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'coref_chain_id', None, None, ), # 1
    (2, TType.LIST, 'mentions', (TType.STRUCT,(Mention, Mention.thrift_spec)), [
    ], ), # 2
    (3, TType.I32, 'best_id', None, None, ), # 3
    (4, TType.LIST, 'entity_classes', (TType.STRUCT,(EntityClassAddress, EntityClassAddress.thrift_spec)), [
    ], ), # 4
    (5, TType.LIST, 'descriptions', (TType.I32,None), [
    ], ), # 5
    (6, TType.MAP, 'associations', (TType.STRING,None,TType.LIST,(TType.I32,None)), {
    }, ), # 6
    (7, TType.LIST, 'kb_links', (TType.STRUCT,(Label, Label.thrift_spec)), [
    ], ), # 7
  )

  def __init__(self, coref_chain_id=None, mentions=thrift_spec[2][4], best_id=None, entity_classes=thrift_spec[4][4], descriptions=thrift_spec[5][4], associations=thrift_spec[6][4], kb_links=thrift_spec[7][4],):
    self.coref_chain_id = coref_chain_id
    if mentions is self.thrift_spec[2][4]:
      mentions = [
    ]
    self.mentions = mentions
    self.best_id = best_id
    if entity_classes is self.thrift_spec[4][4]:
      entity_classes = [
    ]
    self.entity_classes = entity_classes
    if descriptions is self.thrift_spec[5][4]:
      descriptions = [
    ]
    self.descriptions = descriptions
    if associations is self.thrift_spec[6][4]:
      associations = {
    }
    self.associations = associations
    if kb_links is self.thrift_spec[7][4]:
      kb_links = [
    ]
    self.kb_links = kb_links

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.coref_chain_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.mentions = []
          (_etype113, _size110) = iprot.readListBegin()
          for _i114 in xrange(_size110):
            _elem115 = Mention()
            _elem115.read(iprot)
            self.mentions.append(_elem115)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.best_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.entity_classes = []
          (_etype119, _size116) = iprot.readListBegin()
          for _i120 in xrange(_size116):
            _elem121 = EntityClassAddress()
            _elem121.read(iprot)
            self.entity_classes.append(_elem121)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.descriptions = []
          (_etype125, _size122) = iprot.readListBegin()
          for _i126 in xrange(_size122):
            _elem127 = iprot.readI32();
            self.descriptions.append(_elem127)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.associations = {}
          (_ktype129, _vtype130, _size128 ) = iprot.readMapBegin() 
          for _i132 in xrange(_size128):
            _key133 = iprot.readString();
            _val134 = []
            (_etype138, _size135) = iprot.readListBegin()
            for _i139 in xrange(_size135):
              _elem140 = iprot.readI32();
              _val134.append(_elem140)
            iprot.readListEnd()
            self.associations[_key133] = _val134
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.kb_links = []
          (_etype144, _size141) = iprot.readListBegin()
          for _i145 in xrange(_size141):
            _elem146 = Label()
            _elem146.read(iprot)
            self.kb_links.append(_elem146)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Entity')
    if self.coref_chain_id is not None:
      oprot.writeFieldBegin('coref_chain_id', TType.STRING, 1)
      oprot.writeString(self.coref_chain_id)
      oprot.writeFieldEnd()
    if self.mentions is not None:
      oprot.writeFieldBegin('mentions', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.mentions))
      for iter147 in self.mentions:
        iter147.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.best_id is not None:
      oprot.writeFieldBegin('best_id', TType.I32, 3)
      oprot.writeI32(self.best_id)
      oprot.writeFieldEnd()
    if self.entity_classes is not None:
      oprot.writeFieldBegin('entity_classes', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.entity_classes))
      for iter148 in self.entity_classes:
        iter148.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.descriptions is not None:
      oprot.writeFieldBegin('descriptions', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.descriptions))
      for iter149 in self.descriptions:
        oprot.writeI32(iter149)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.associations is not None:
      oprot.writeFieldBegin('associations', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.associations))
      for kiter150,viter151 in self.associations.items():
        oprot.writeString(kiter150)
        oprot.writeListBegin(TType.I32, len(viter151))
        for iter152 in viter151:
          oprot.writeI32(iter152)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.kb_links is not None:
      oprot.writeFieldBegin('kb_links', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.kb_links))
      for iter153 in self.kb_links:
        iter153.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ContentItem(object):
  """
  ContentItem contains raw data, an indication of its character
  encoding, and various transformed versions of the raw data.

  Attributes:
   - raw: original download, raw byte array
   - encoding: guessed from raw and/or headers, e.g. by python-requests.org
   - media_type: Content-type header from fetching the data, or MIME type
   - clean_html: HTML-formatted version of raw with UTF8 encoding and no broken
  tags.  All HTML-escaped characters are converted to their UTF8
  equivalents.  < > & are escaped.
   - clean_visible: All tags stripped from clean_html and replaced with whitespace,
  so they have the same byte offsets.  The only escaped characters
  are < > &, so that this can be treated as Character Data in XML:
  http://www.w3.org/TR/xml/#syntax

  Again: must be UTF8
   - logs: Logs generated from processing pipeline, for forensics
   - taggings: A set of auto-generated taggings, such as a One-Word-Per-Line
  (OWLP) tokenization and sentence chunking with part-of-speech,
  lemmatization, and NER classification.  The string name should be
  the same as the tagger_id and also corresponds to the key in
  sentences or sentence_blobs, which get generated by transforming
  a Tagging.raw_tagging into Sentence and Token instances

  Taggings are generated from 'clean_visible' so offsets (byte,
  char, line) refer to clean_visible and clean_html -- not raw.
   - labels: sets of annotations
   - sentences: parsed Sentence objects generated by an NLP pipeline identified
  by the string name, which is a tagger_id that connects this
  Sentences instance to the Tagging struct from which it came
   - sentence_blobs: same as 'sentences' except the array of Sentence instances are
  serialized into a binary string that can be read by the Thrift's
  binary protocol.  This allows lazy deserialization via an
  iterator -- one sentence at a time.  This might be totally
  unnecessary, because at least some of the Thrift language
  implementations have lazy object construction, e.g. --gen
  py:dynamic,slots
   - language: indication of which natural language is used in the text
   - relations: List of relations discovered in clean_visible
   - attributes: List of attributes discovered in clean_visible
   - external_ids: Map of external identifier strings to mention_ids generated by a
  particular tagger.  This allows external systems to associate
  record IDs with individual mentions, or sets of mentions.
   - selectors: Map of external identifier strings to selectors in clean_visible
   - zones: Map of external identifier strings to Zones.  As indicated by
  content_form or content_cleanse_level in the Offset, it may refer
  to clean_visible or raw_characters.
   - raw_characters: Unicode character string represented as UTF-8 bytes from decoding
  the binary `raw` data.
   - span_lengths: Ordered list of the lengths of spans in `raw_characters`
   - span_types: See description of `SpanType`
   - spans: List of strings split at `span_lengths`

  In the interest of saving space, an implementation may omit `raw`
  and `raw_characters` in favor of using `spans` as the primary
  form of the content.

  An implementation may set MARKUP spans to '' and represent the
  MARKUP in span_xpaths.

   if not ContentItem.span_xpaths:
       assert u''.join(spans) == raw_characters
   else:
       assert len(spans) == len(span_xpaths)

  Since span_lengths is redundant, it could be omitted.  If
  present, then:

   if ContentItem.span_lengths:
       assert len(spans) == len(span_lengths)

  Note the lack of TaggerID.  This is a *single* primary
  tokenization of the document that a system could construct from a
  primary tokenizer and possibly further modify by token
  "improvers."
   - span_xpaths: List of integers from the HtmlTags enum representing an XPath
  relative to the previous MARKUP span.  For example, a MARKUP span
  of "</p></li></ol><div>" would be [0, 0, 0, 36].
   - normalized_spans: For each position in spans, a list of other strings that a system
  could/should index as variations to boost recall.  This is
  pre-indexing query expansion.  For example, stemmed and
  lemmatized strings appear here.

  assert len(normalized_spans) == len(spans)

  TODO: assess whether this should change to something simpler,
  like a bag-of-word-variants for the whole document.
   - sentence_spans: List of begin/end ranges of spans for sentence chunking; index
  positions into sentence_spans are called `SentenceId`
   - entities: Index from CorefChainID --> Entity structs
   - contexts: ContextId is indexes into this list

  The binary blob is a general way of carrying feature vector data,
  such as dossier.fc.FeatureCollection or other data that is
  constructed and defined by a particular system.
  """

  __slots__ = [ 
    'raw',
    'encoding',
    'media_type',
    'clean_html',
    'clean_visible',
    'logs',
    'taggings',
    'labels',
    'sentences',
    'sentence_blobs',
    'language',
    'relations',
    'attributes',
    'external_ids',
    'selectors',
    'zones',
    'raw_characters',
    'span_lengths',
    'span_types',
    'spans',
    'span_xpaths',
    'normalized_spans',
    'sentence_spans',
    'entities',
    'contexts',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'raw', None, None, ), # 1
    (2, TType.STRING, 'encoding', None, None, ), # 2
    (3, TType.STRING, 'media_type', None, None, ), # 3
    (4, TType.STRING, 'clean_html', None, None, ), # 4
    (5, TType.STRING, 'clean_visible', None, None, ), # 5
    (6, TType.LIST, 'logs', (TType.STRING,None), [
    ], ), # 6
    (7, TType.MAP, 'taggings', (TType.STRING,None,TType.STRUCT,(Tagging, Tagging.thrift_spec)), {
    }, ), # 7
    (8, TType.MAP, 'labels', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Label, Label.thrift_spec))), {
    }, ), # 8
    (9, TType.MAP, 'sentences', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Sentence, Sentence.thrift_spec))), {
    }, ), # 9
    (10, TType.MAP, 'sentence_blobs', (TType.STRING,None,TType.STRING,None), {
    }, ), # 10
    (11, TType.STRUCT, 'language', (Language, Language.thrift_spec), None, ), # 11
    (12, TType.MAP, 'relations', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Relation, Relation.thrift_spec))), {
    }, ), # 12
    (13, TType.MAP, 'attributes', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Attribute, Attribute.thrift_spec))), {
    }, ), # 13
    (14, TType.MAP, 'external_ids', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.STRING,None)), {
    }, ), # 14
    (15, TType.MAP, 'selectors', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Selector, Selector.thrift_spec))), {
    }, ), # 15
    (16, TType.MAP, 'zones', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.STRUCT,(Zone, Zone.thrift_spec))), {
    }, ), # 16
    (17, TType.STRING, 'raw_characters', None, None, ), # 17
    (18, TType.LIST, 'span_lengths', (TType.I32,None), None, ), # 18
    (19, TType.LIST, 'span_types', (TType.I32,None), None, ), # 19
    (20, TType.LIST, 'spans', (TType.STRING,None), None, ), # 20
    (21, TType.LIST, 'span_xpaths', (TType.LIST,(TType.I16,None)), None, ), # 21
    (22, TType.LIST, 'normalized_spans', (TType.LIST,(TType.STRING,None)), None, ), # 22
    (23, TType.LIST, 'sentence_spans', (TType.LIST,(TType.I32,None)), None, ), # 23
    (24, TType.MAP, 'entities', (TType.STRING,None,TType.STRUCT,(Entity, Entity.thrift_spec)), {
    }, ), # 24
    (25, TType.LIST, 'contexts', (TType.STRING,None), [
    ], ), # 25
  )

  def __init__(self, raw=None, encoding=None, media_type=None, clean_html=None, clean_visible=None, logs=thrift_spec[6][4], taggings=thrift_spec[7][4], labels=thrift_spec[8][4], sentences=thrift_spec[9][4], sentence_blobs=thrift_spec[10][4], language=None, relations=thrift_spec[12][4], attributes=thrift_spec[13][4], external_ids=thrift_spec[14][4], selectors=thrift_spec[15][4], zones=thrift_spec[16][4], raw_characters=None, span_lengths=None, span_types=None, spans=None, span_xpaths=None, normalized_spans=None, sentence_spans=None, entities=thrift_spec[24][4], contexts=thrift_spec[25][4],):
    self.raw = raw
    self.encoding = encoding
    self.media_type = media_type
    self.clean_html = clean_html
    self.clean_visible = clean_visible
    if logs is self.thrift_spec[6][4]:
      logs = [
    ]
    self.logs = logs
    if taggings is self.thrift_spec[7][4]:
      taggings = {
    }
    self.taggings = taggings
    if labels is self.thrift_spec[8][4]:
      labels = {
    }
    self.labels = labels
    if sentences is self.thrift_spec[9][4]:
      sentences = {
    }
    self.sentences = sentences
    if sentence_blobs is self.thrift_spec[10][4]:
      sentence_blobs = {
    }
    self.sentence_blobs = sentence_blobs
    self.language = language
    if relations is self.thrift_spec[12][4]:
      relations = {
    }
    self.relations = relations
    if attributes is self.thrift_spec[13][4]:
      attributes = {
    }
    self.attributes = attributes
    if external_ids is self.thrift_spec[14][4]:
      external_ids = {
    }
    self.external_ids = external_ids
    if selectors is self.thrift_spec[15][4]:
      selectors = {
    }
    self.selectors = selectors
    if zones is self.thrift_spec[16][4]:
      zones = {
    }
    self.zones = zones
    self.raw_characters = raw_characters
    self.span_lengths = span_lengths
    self.span_types = span_types
    self.spans = spans
    self.span_xpaths = span_xpaths
    self.normalized_spans = normalized_spans
    self.sentence_spans = sentence_spans
    if entities is self.thrift_spec[24][4]:
      entities = {
    }
    self.entities = entities
    if contexts is self.thrift_spec[25][4]:
      contexts = [
    ]
    self.contexts = contexts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.raw = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.encoding = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.media_type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.clean_html = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.clean_visible = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.logs = []
          (_etype157, _size154) = iprot.readListBegin()
          for _i158 in xrange(_size154):
            _elem159 = iprot.readString();
            self.logs.append(_elem159)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.taggings = {}
          (_ktype161, _vtype162, _size160 ) = iprot.readMapBegin() 
          for _i164 in xrange(_size160):
            _key165 = iprot.readString();
            _val166 = Tagging()
            _val166.read(iprot)
            self.taggings[_key165] = _val166
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.labels = {}
          (_ktype168, _vtype169, _size167 ) = iprot.readMapBegin() 
          for _i171 in xrange(_size167):
            _key172 = iprot.readString();
            _val173 = []
            (_etype177, _size174) = iprot.readListBegin()
            for _i178 in xrange(_size174):
              _elem179 = Label()
              _elem179.read(iprot)
              _val173.append(_elem179)
            iprot.readListEnd()
            self.labels[_key172] = _val173
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.sentences = {}
          (_ktype181, _vtype182, _size180 ) = iprot.readMapBegin() 
          for _i184 in xrange(_size180):
            _key185 = iprot.readString();
            _val186 = []
            (_etype190, _size187) = iprot.readListBegin()
            for _i191 in xrange(_size187):
              _elem192 = Sentence()
              _elem192.read(iprot)
              _val186.append(_elem192)
            iprot.readListEnd()
            self.sentences[_key185] = _val186
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.sentence_blobs = {}
          (_ktype194, _vtype195, _size193 ) = iprot.readMapBegin() 
          for _i197 in xrange(_size193):
            _key198 = iprot.readString();
            _val199 = iprot.readString();
            self.sentence_blobs[_key198] = _val199
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.language = Language()
          self.language.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.MAP:
          self.relations = {}
          (_ktype201, _vtype202, _size200 ) = iprot.readMapBegin() 
          for _i204 in xrange(_size200):
            _key205 = iprot.readString();
            _val206 = []
            (_etype210, _size207) = iprot.readListBegin()
            for _i211 in xrange(_size207):
              _elem212 = Relation()
              _elem212.read(iprot)
              _val206.append(_elem212)
            iprot.readListEnd()
            self.relations[_key205] = _val206
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype214, _vtype215, _size213 ) = iprot.readMapBegin() 
          for _i217 in xrange(_size213):
            _key218 = iprot.readString();
            _val219 = []
            (_etype223, _size220) = iprot.readListBegin()
            for _i224 in xrange(_size220):
              _elem225 = Attribute()
              _elem225.read(iprot)
              _val219.append(_elem225)
            iprot.readListEnd()
            self.attributes[_key218] = _val219
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.MAP:
          self.external_ids = {}
          (_ktype227, _vtype228, _size226 ) = iprot.readMapBegin() 
          for _i230 in xrange(_size226):
            _key231 = iprot.readString();
            _val232 = {}
            (_ktype234, _vtype235, _size233 ) = iprot.readMapBegin() 
            for _i237 in xrange(_size233):
              _key238 = iprot.readI32();
              _val239 = iprot.readString();
              _val232[_key238] = _val239
            iprot.readMapEnd()
            self.external_ids[_key231] = _val232
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.MAP:
          self.selectors = {}
          (_ktype241, _vtype242, _size240 ) = iprot.readMapBegin() 
          for _i244 in xrange(_size240):
            _key245 = iprot.readString();
            _val246 = []
            (_etype250, _size247) = iprot.readListBegin()
            for _i251 in xrange(_size247):
              _elem252 = Selector()
              _elem252.read(iprot)
              _val246.append(_elem252)
            iprot.readListEnd()
            self.selectors[_key245] = _val246
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.MAP:
          self.zones = {}
          (_ktype254, _vtype255, _size253 ) = iprot.readMapBegin() 
          for _i257 in xrange(_size253):
            _key258 = iprot.readString();
            _val259 = {}
            (_ktype261, _vtype262, _size260 ) = iprot.readMapBegin() 
            for _i264 in xrange(_size260):
              _key265 = iprot.readI32();
              _val266 = Zone()
              _val266.read(iprot)
              _val259[_key265] = _val266
            iprot.readMapEnd()
            self.zones[_key258] = _val259
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.raw_characters = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.LIST:
          self.span_lengths = []
          (_etype270, _size267) = iprot.readListBegin()
          for _i271 in xrange(_size267):
            _elem272 = iprot.readI32();
            self.span_lengths.append(_elem272)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.LIST:
          self.span_types = []
          (_etype276, _size273) = iprot.readListBegin()
          for _i277 in xrange(_size273):
            _elem278 = iprot.readI32();
            self.span_types.append(_elem278)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.LIST:
          self.spans = []
          (_etype282, _size279) = iprot.readListBegin()
          for _i283 in xrange(_size279):
            _elem284 = iprot.readString();
            self.spans.append(_elem284)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.LIST:
          self.span_xpaths = []
          (_etype288, _size285) = iprot.readListBegin()
          for _i289 in xrange(_size285):
            _elem290 = []
            (_etype294, _size291) = iprot.readListBegin()
            for _i295 in xrange(_size291):
              _elem296 = iprot.readI16();
              _elem290.append(_elem296)
            iprot.readListEnd()
            self.span_xpaths.append(_elem290)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.LIST:
          self.normalized_spans = []
          (_etype300, _size297) = iprot.readListBegin()
          for _i301 in xrange(_size297):
            _elem302 = []
            (_etype306, _size303) = iprot.readListBegin()
            for _i307 in xrange(_size303):
              _elem308 = iprot.readString();
              _elem302.append(_elem308)
            iprot.readListEnd()
            self.normalized_spans.append(_elem302)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.LIST:
          self.sentence_spans = []
          (_etype312, _size309) = iprot.readListBegin()
          for _i313 in xrange(_size309):
            _elem314 = []
            (_etype318, _size315) = iprot.readListBegin()
            for _i319 in xrange(_size315):
              _elem320 = iprot.readI32();
              _elem314.append(_elem320)
            iprot.readListEnd()
            self.sentence_spans.append(_elem314)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.MAP:
          self.entities = {}
          (_ktype322, _vtype323, _size321 ) = iprot.readMapBegin() 
          for _i325 in xrange(_size321):
            _key326 = iprot.readString();
            _val327 = Entity()
            _val327.read(iprot)
            self.entities[_key326] = _val327
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.LIST:
          self.contexts = []
          (_etype331, _size328) = iprot.readListBegin()
          for _i332 in xrange(_size328):
            _elem333 = iprot.readString();
            self.contexts.append(_elem333)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ContentItem')
    if self.raw is not None:
      oprot.writeFieldBegin('raw', TType.STRING, 1)
      oprot.writeString(self.raw)
      oprot.writeFieldEnd()
    if self.encoding is not None:
      oprot.writeFieldBegin('encoding', TType.STRING, 2)
      oprot.writeString(self.encoding)
      oprot.writeFieldEnd()
    if self.media_type is not None:
      oprot.writeFieldBegin('media_type', TType.STRING, 3)
      oprot.writeString(self.media_type)
      oprot.writeFieldEnd()
    if self.clean_html is not None:
      oprot.writeFieldBegin('clean_html', TType.STRING, 4)
      oprot.writeString(self.clean_html)
      oprot.writeFieldEnd()
    if self.clean_visible is not None:
      oprot.writeFieldBegin('clean_visible', TType.STRING, 5)
      oprot.writeString(self.clean_visible)
      oprot.writeFieldEnd()
    if self.logs is not None:
      oprot.writeFieldBegin('logs', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.logs))
      for iter334 in self.logs:
        oprot.writeString(iter334)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.taggings is not None:
      oprot.writeFieldBegin('taggings', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.taggings))
      for kiter335,viter336 in self.taggings.items():
        oprot.writeString(kiter335)
        viter336.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.labels is not None:
      oprot.writeFieldBegin('labels', TType.MAP, 8)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.labels))
      for kiter337,viter338 in self.labels.items():
        oprot.writeString(kiter337)
        oprot.writeListBegin(TType.STRUCT, len(viter338))
        for iter339 in viter338:
          iter339.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.sentences is not None:
      oprot.writeFieldBegin('sentences', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.sentences))
      for kiter340,viter341 in self.sentences.items():
        oprot.writeString(kiter340)
        oprot.writeListBegin(TType.STRUCT, len(viter341))
        for iter342 in viter341:
          iter342.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.sentence_blobs is not None:
      oprot.writeFieldBegin('sentence_blobs', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.sentence_blobs))
      for kiter343,viter344 in self.sentence_blobs.items():
        oprot.writeString(kiter343)
        oprot.writeString(viter344)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.language is not None:
      oprot.writeFieldBegin('language', TType.STRUCT, 11)
      self.language.write(oprot)
      oprot.writeFieldEnd()
    if self.relations is not None:
      oprot.writeFieldBegin('relations', TType.MAP, 12)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.relations))
      for kiter345,viter346 in self.relations.items():
        oprot.writeString(kiter345)
        oprot.writeListBegin(TType.STRUCT, len(viter346))
        for iter347 in viter346:
          iter347.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 13)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.attributes))
      for kiter348,viter349 in self.attributes.items():
        oprot.writeString(kiter348)
        oprot.writeListBegin(TType.STRUCT, len(viter349))
        for iter350 in viter349:
          iter350.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.external_ids is not None:
      oprot.writeFieldBegin('external_ids', TType.MAP, 14)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.external_ids))
      for kiter351,viter352 in self.external_ids.items():
        oprot.writeString(kiter351)
        oprot.writeMapBegin(TType.I32, TType.STRING, len(viter352))
        for kiter353,viter354 in viter352.items():
          oprot.writeI32(kiter353)
          oprot.writeString(viter354)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.selectors is not None:
      oprot.writeFieldBegin('selectors', TType.MAP, 15)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.selectors))
      for kiter355,viter356 in self.selectors.items():
        oprot.writeString(kiter355)
        oprot.writeListBegin(TType.STRUCT, len(viter356))
        for iter357 in viter356:
          iter357.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.zones is not None:
      oprot.writeFieldBegin('zones', TType.MAP, 16)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.zones))
      for kiter358,viter359 in self.zones.items():
        oprot.writeString(kiter358)
        oprot.writeMapBegin(TType.I32, TType.STRUCT, len(viter359))
        for kiter360,viter361 in viter359.items():
          oprot.writeI32(kiter360)
          viter361.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.raw_characters is not None:
      oprot.writeFieldBegin('raw_characters', TType.STRING, 17)
      oprot.writeString(self.raw_characters)
      oprot.writeFieldEnd()
    if self.span_lengths is not None:
      oprot.writeFieldBegin('span_lengths', TType.LIST, 18)
      oprot.writeListBegin(TType.I32, len(self.span_lengths))
      for iter362 in self.span_lengths:
        oprot.writeI32(iter362)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.span_types is not None:
      oprot.writeFieldBegin('span_types', TType.LIST, 19)
      oprot.writeListBegin(TType.I32, len(self.span_types))
      for iter363 in self.span_types:
        oprot.writeI32(iter363)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.spans is not None:
      oprot.writeFieldBegin('spans', TType.LIST, 20)
      oprot.writeListBegin(TType.STRING, len(self.spans))
      for iter364 in self.spans:
        oprot.writeString(iter364)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.span_xpaths is not None:
      oprot.writeFieldBegin('span_xpaths', TType.LIST, 21)
      oprot.writeListBegin(TType.LIST, len(self.span_xpaths))
      for iter365 in self.span_xpaths:
        oprot.writeListBegin(TType.I16, len(iter365))
        for iter366 in iter365:
          oprot.writeI16(iter366)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.normalized_spans is not None:
      oprot.writeFieldBegin('normalized_spans', TType.LIST, 22)
      oprot.writeListBegin(TType.LIST, len(self.normalized_spans))
      for iter367 in self.normalized_spans:
        oprot.writeListBegin(TType.STRING, len(iter367))
        for iter368 in iter367:
          oprot.writeString(iter368)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sentence_spans is not None:
      oprot.writeFieldBegin('sentence_spans', TType.LIST, 23)
      oprot.writeListBegin(TType.LIST, len(self.sentence_spans))
      for iter369 in self.sentence_spans:
        oprot.writeListBegin(TType.I32, len(iter369))
        for iter370 in iter369:
          oprot.writeI32(iter370)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.entities is not None:
      oprot.writeFieldBegin('entities', TType.MAP, 24)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.entities))
      for kiter371,viter372 in self.entities.items():
        oprot.writeString(kiter371)
        viter372.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.contexts is not None:
      oprot.writeFieldBegin('contexts', TType.LIST, 25)
      oprot.writeListBegin(TType.STRING, len(self.contexts))
      for iter373 in self.contexts:
        oprot.writeString(iter373)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Rating(object):
  """
  Ratings are buman generated assertions about a entire document's
  utility for a particular topic or entity in a reference KB.

  Attributes:
   - annotator: identifies the source of this Rating
   - target: identifies the information need assessed by annotator
   - relevance: numerical score assigned by annotator to "judge" or "rate" the
  utility of this StreamItem to addressing the target information
  need.  The range and interpretation of relevance numbers depends
  on the annotator.  relevance can represent a rank ordering or an
  enumeration such as -1=Garbage, 0=Neutral, 1=Useful, 2=Vital
   - contains_mention: true|false indication of whether the document mentions the target
  entity.  This is only partially correlated with relevance.  For
  example, a document might mention the entity only in chrome text
  on the side such that it is a Garbage-rated text for that entity.
   - comments: Save notes from Annotator about this Rating
   - mentions: Record strings that are "mentions" of the target in this text
   - flags: General purpose flags. These flags can be used to mark documents
  as meeting an extensible set of criteria.
  """

  __slots__ = [ 
    'annotator',
    'target',
    'relevance',
    'contains_mention',
    'comments',
    'mentions',
    'flags',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'annotator', (Annotator, Annotator.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'target', (Target, Target.thrift_spec), None, ), # 2
    (3, TType.I16, 'relevance', None, None, ), # 3
    (4, TType.BOOL, 'contains_mention', None, None, ), # 4
    (5, TType.STRING, 'comments', None, None, ), # 5
    (6, TType.LIST, 'mentions', (TType.STRING,None), None, ), # 6
    (7, TType.LIST, 'flags', (TType.I32,None), None, ), # 7
  )

  def __init__(self, annotator=None, target=None, relevance=None, contains_mention=None, comments=None, mentions=None, flags=None,):
    self.annotator = annotator
    self.target = target
    self.relevance = relevance
    self.contains_mention = contains_mention
    self.comments = comments
    self.mentions = mentions
    self.flags = flags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.annotator = Annotator()
          self.annotator.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.target = Target()
          self.target.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.relevance = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.contains_mention = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.comments = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.mentions = []
          (_etype377, _size374) = iprot.readListBegin()
          for _i378 in xrange(_size374):
            _elem379 = iprot.readString();
            self.mentions.append(_elem379)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.flags = []
          (_etype383, _size380) = iprot.readListBegin()
          for _i384 in xrange(_size380):
            _elem385 = iprot.readI32();
            self.flags.append(_elem385)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Rating')
    if self.annotator is not None:
      oprot.writeFieldBegin('annotator', TType.STRUCT, 1)
      self.annotator.write(oprot)
      oprot.writeFieldEnd()
    if self.target is not None:
      oprot.writeFieldBegin('target', TType.STRUCT, 2)
      self.target.write(oprot)
      oprot.writeFieldEnd()
    if self.relevance is not None:
      oprot.writeFieldBegin('relevance', TType.I16, 3)
      oprot.writeI16(self.relevance)
      oprot.writeFieldEnd()
    if self.contains_mention is not None:
      oprot.writeFieldBegin('contains_mention', TType.BOOL, 4)
      oprot.writeBool(self.contains_mention)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 5)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    if self.mentions is not None:
      oprot.writeFieldBegin('mentions', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.mentions))
      for iter386 in self.mentions:
        oprot.writeString(iter386)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.LIST, 7)
      oprot.writeListBegin(TType.I32, len(self.flags))
      for iter387 in self.flags:
        oprot.writeI32(iter387)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class HttpTransaction(object):
  """
  When content is retrieved from remote servers, useful data can be
  buried in the request-response data of HTTP Transactions.  In
  particular, redirect chains can help identify duplicate documents,
  and information can be embedded in the various URLs that point at a
  document.

  For more details, see http://blog.catchpoint.com/2010/09/17/anatomyhttp/

  Attributes:
   - hostname: hostname sent to DNS
   - ip_address: IP address obtained from DNS
   - request: byte string of HTTP Request
   - response: byte string of HTTP Response headers *without* the body.
   - body: Data from an HTTP *before* the final transaction.  The final
  transaction creates the `body` property on the `StreamItem`.  It
  is possible for an HTTP Redirect to have a non-empty body,
  e.g. an interstitial page saying "standby". This `body` property
  is intended to capture that data when present.
  """

  __slots__ = [ 
    'hostname',
    'ip_address',
    'request',
    'response',
    'body',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hostname', None, None, ), # 1
    (2, TType.STRING, 'ip_address', None, None, ), # 2
    (3, TType.STRING, 'request', None, None, ), # 3
    (4, TType.STRING, 'response', None, None, ), # 4
    (5, TType.STRUCT, 'body', (ContentItem, ContentItem.thrift_spec), None, ), # 5
  )

  def __init__(self, hostname=None, ip_address=None, request=None, response=None, body=None,):
    self.hostname = hostname
    self.ip_address = ip_address
    self.request = request
    self.response = response
    self.body = body

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hostname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ip_address = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.request = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.response = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.body = ContentItem()
          self.body.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HttpTransaction')
    if self.hostname is not None:
      oprot.writeFieldBegin('hostname', TType.STRING, 1)
      oprot.writeString(self.hostname)
      oprot.writeFieldEnd()
    if self.ip_address is not None:
      oprot.writeFieldBegin('ip_address', TType.STRING, 2)
      oprot.writeString(self.ip_address)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRING, 3)
      oprot.writeString(self.request)
      oprot.writeFieldEnd()
    if self.response is not None:
      oprot.writeFieldBegin('response', TType.STRING, 4)
      oprot.writeString(self.response)
      oprot.writeFieldEnd()
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.STRUCT, 5)
      self.body.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class StreamItem(object):
  """
  This is the primary interface to the corpus data.  It is called
  StreamItem rather than CorpusItem and has a required StreamTime
  attribute, because even for a static corpus, each document was
  captured at a particular time in Earth history and might have been
  different if captured earlier or later.  All corpora are stream
  corpora, even if they were not explicitly created as such.

  stream_id is the unique identifier for documents in the corpus.

  This is similar to the StreamItem defined in kba.thrift for TREC
  KBA 2012, however it removes the 'title' and 'anchor' fields, which
  can now be represented in other_content.  This means that code that
  was written to read messages from kba.thrift must be updated.

  Attributes:
   - version: must provide a version number here
   - doc_id: md5 hash of the abs_url
   - abs_url: normalized form of the original_url, should be a valid URL
   - schost: scheme://hostname parsed from abs_url
   - original_url: string obtain from some source.  Only present if not a valid URL,
  in which case abs_url was derived from original_url
   - source: string uniquely identifying this data set, should start with a
  year string, such as 'news' or 'social'
   - body: primary content
   - source_metadata: see above for explanation of the values that can appear in this
  dictionary of metadata info from the source.  The string keys in
  this map should be short, descriptive, and free of whitespace.
   - stream_id: stream_id is actual unique identifier for a StreamItem.  The
  format is:

  stream_id = '%d-%s' % (int(stream_time.epoch_ticks), doc_id)
   - stream_time: earliest time that this content was known to exist.  Usually,
  body.raw was also saved at the time of that first observation.
   - other_content: such as title, anchor, extracted, etc.  When present, 'anchor',
  is a single anchor text of a URL pointing to this doc.  Note that
  this does not have metadata like the URL of the page that
  contained this anchor.  Such general link graph data may
  eventually motivate an extension to this thrift interface.
   - ratings: doc-level judgments relating entire StreamItem to a Target
   - external_ids: doc-level map connecting either doc_id or stream_id (or both) to
  external identifiers.  This allows external systems to associate
  record IDs with individual doc_id or stream_id of this document.
  The keys in the second level map can be either doc_id or
  stream_id, or possibly other IDs in the future.
   - http_transactions: If provided, this lists the sequence of possibly multiple HTTP
  Transactions that led to the `body` `ContentItem`.  The first
  item in the list is the initial request-response, and the last
  item in the list is the request-response that carried the body
  content that became the `body` attribute on this `StreamItem`.
  Multiple transactions result from *redirects*.  The `abs_url` is
  the *final* URL in the redirect chain, and the `original_url` is
  the original string that may have required cleanup before
  initiating the first request that started the chain.
  """

  __slots__ = [ 
    'version',
    'doc_id',
    'abs_url',
    'schost',
    'original_url',
    'source',
    'body',
    'source_metadata',
    'stream_id',
    'stream_time',
    'other_content',
    'ratings',
    'external_ids',
    'http_transactions',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None,     2, ), # 1
    (2, TType.STRING, 'doc_id', None, None, ), # 2
    (3, TType.STRING, 'abs_url', None, None, ), # 3
    (4, TType.STRING, 'schost', None, None, ), # 4
    (5, TType.STRING, 'original_url', None, None, ), # 5
    (6, TType.STRING, 'source', None, None, ), # 6
    (7, TType.STRUCT, 'body', (ContentItem, ContentItem.thrift_spec), None, ), # 7
    (8, TType.MAP, 'source_metadata', (TType.STRING,None,TType.STRING,None), {
    }, ), # 8
    (9, TType.STRING, 'stream_id', None, None, ), # 9
    (10, TType.STRUCT, 'stream_time', (StreamTime, StreamTime.thrift_spec), None, ), # 10
    (11, TType.MAP, 'other_content', (TType.STRING,None,TType.STRUCT,(ContentItem, ContentItem.thrift_spec)), {
    }, ), # 11
    (12, TType.MAP, 'ratings', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Rating, Rating.thrift_spec))), {
    }, ), # 12
    None, # 13
    (14, TType.MAP, 'external_ids', (TType.STRING,None,TType.MAP,(TType.STRING,None,TType.STRING,None)), {
    }, ), # 14
    (15, TType.LIST, 'http_transactions', (TType.STRUCT,(HttpTransaction, HttpTransaction.thrift_spec)), [
    ], ), # 15
  )

  def __init__(self, version=thrift_spec[1][4], doc_id=None, abs_url=None, schost=None, original_url=None, source=None, body=None, source_metadata=thrift_spec[8][4], stream_id=None, stream_time=None, other_content=thrift_spec[11][4], ratings=thrift_spec[12][4], external_ids=thrift_spec[14][4], http_transactions=thrift_spec[15][4],):
    self.version = version
    self.doc_id = doc_id
    self.abs_url = abs_url
    self.schost = schost
    self.original_url = original_url
    self.source = source
    self.body = body
    if source_metadata is self.thrift_spec[8][4]:
      source_metadata = {
    }
    self.source_metadata = source_metadata
    self.stream_id = stream_id
    self.stream_time = stream_time
    if other_content is self.thrift_spec[11][4]:
      other_content = {
    }
    self.other_content = other_content
    if ratings is self.thrift_spec[12][4]:
      ratings = {
    }
    self.ratings = ratings
    if external_ids is self.thrift_spec[14][4]:
      external_ids = {
    }
    self.external_ids = external_ids
    if http_transactions is self.thrift_spec[15][4]:
      http_transactions = [
    ]
    self.http_transactions = http_transactions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.doc_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.abs_url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.schost = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.original_url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.body = ContentItem()
          self.body.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.source_metadata = {}
          (_ktype389, _vtype390, _size388 ) = iprot.readMapBegin() 
          for _i392 in xrange(_size388):
            _key393 = iprot.readString();
            _val394 = iprot.readString();
            self.source_metadata[_key393] = _val394
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.stream_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.stream_time = StreamTime()
          self.stream_time.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.MAP:
          self.other_content = {}
          (_ktype396, _vtype397, _size395 ) = iprot.readMapBegin() 
          for _i399 in xrange(_size395):
            _key400 = iprot.readString();
            _val401 = ContentItem()
            _val401.read(iprot)
            self.other_content[_key400] = _val401
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.MAP:
          self.ratings = {}
          (_ktype403, _vtype404, _size402 ) = iprot.readMapBegin() 
          for _i406 in xrange(_size402):
            _key407 = iprot.readString();
            _val408 = []
            (_etype412, _size409) = iprot.readListBegin()
            for _i413 in xrange(_size409):
              _elem414 = Rating()
              _elem414.read(iprot)
              _val408.append(_elem414)
            iprot.readListEnd()
            self.ratings[_key407] = _val408
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.MAP:
          self.external_ids = {}
          (_ktype416, _vtype417, _size415 ) = iprot.readMapBegin() 
          for _i419 in xrange(_size415):
            _key420 = iprot.readString();
            _val421 = {}
            (_ktype423, _vtype424, _size422 ) = iprot.readMapBegin() 
            for _i426 in xrange(_size422):
              _key427 = iprot.readString();
              _val428 = iprot.readString();
              _val421[_key427] = _val428
            iprot.readMapEnd()
            self.external_ids[_key420] = _val421
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.http_transactions = []
          (_etype432, _size429) = iprot.readListBegin()
          for _i433 in xrange(_size429):
            _elem434 = HttpTransaction()
            _elem434.read(iprot)
            self.http_transactions.append(_elem434)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamItem')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.doc_id is not None:
      oprot.writeFieldBegin('doc_id', TType.STRING, 2)
      oprot.writeString(self.doc_id)
      oprot.writeFieldEnd()
    if self.abs_url is not None:
      oprot.writeFieldBegin('abs_url', TType.STRING, 3)
      oprot.writeString(self.abs_url)
      oprot.writeFieldEnd()
    if self.schost is not None:
      oprot.writeFieldBegin('schost', TType.STRING, 4)
      oprot.writeString(self.schost)
      oprot.writeFieldEnd()
    if self.original_url is not None:
      oprot.writeFieldBegin('original_url', TType.STRING, 5)
      oprot.writeString(self.original_url)
      oprot.writeFieldEnd()
    if self.source is not None:
      oprot.writeFieldBegin('source', TType.STRING, 6)
      oprot.writeString(self.source)
      oprot.writeFieldEnd()
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.STRUCT, 7)
      self.body.write(oprot)
      oprot.writeFieldEnd()
    if self.source_metadata is not None:
      oprot.writeFieldBegin('source_metadata', TType.MAP, 8)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.source_metadata))
      for kiter435,viter436 in self.source_metadata.items():
        oprot.writeString(kiter435)
        oprot.writeString(viter436)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stream_id is not None:
      oprot.writeFieldBegin('stream_id', TType.STRING, 9)
      oprot.writeString(self.stream_id)
      oprot.writeFieldEnd()
    if self.stream_time is not None:
      oprot.writeFieldBegin('stream_time', TType.STRUCT, 10)
      self.stream_time.write(oprot)
      oprot.writeFieldEnd()
    if self.other_content is not None:
      oprot.writeFieldBegin('other_content', TType.MAP, 11)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.other_content))
      for kiter437,viter438 in self.other_content.items():
        oprot.writeString(kiter437)
        viter438.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ratings is not None:
      oprot.writeFieldBegin('ratings', TType.MAP, 12)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.ratings))
      for kiter439,viter440 in self.ratings.items():
        oprot.writeString(kiter439)
        oprot.writeListBegin(TType.STRUCT, len(viter440))
        for iter441 in viter440:
          iter441.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.external_ids is not None:
      oprot.writeFieldBegin('external_ids', TType.MAP, 14)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.external_ids))
      for kiter442,viter443 in self.external_ids.items():
        oprot.writeString(kiter442)
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter443))
        for kiter444,viter445 in viter443.items():
          oprot.writeString(kiter444)
          oprot.writeString(viter445)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.http_transactions is not None:
      oprot.writeFieldBegin('http_transactions', TType.LIST, 15)
      oprot.writeListBegin(TType.STRUCT, len(self.http_transactions))
      for iter446 in self.http_transactions:
        iter446.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)

